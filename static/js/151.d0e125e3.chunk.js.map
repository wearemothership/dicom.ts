{"version":3,"file":"static/js/151.d0e125e3.chunk.js","mappings":"6JA4FA,SAASA,EAAOC,EAAWC,GAC1B,MAAM,eAAEC,GAAmBF,EAC3B,GAAuB,IAAnBE,EACH,OA5FF,SAAiBF,EAAWG,GAC3B,MAAM,QAAEC,EAAF,KAAWC,GAASL,EACpBM,EAAUD,EAAKE,eACfC,EAAU,IAAIC,YAAYH,EAAUF,GACpCM,EAAO,IAAIC,WAAWR,EAASS,OAAQT,EAASU,WAAYV,EAASW,YACrEC,EAAM,IAAIJ,WAAWH,GAE3B,IAAIQ,EAAW,EACf,MAAMC,EAAcd,EAASe,SAAS,GAAG,GAEnCC,EAAeb,EAAUW,EAE/B,IAAK,IAAIG,EAAI,EAAGA,EAAIH,IAAeG,EAAG,CACrCJ,EAAWI,EAEX,IAOIC,EACAC,EACAC,EATAC,EAAUrB,EAASe,SAAmB,GAATE,EAAI,IAAQ,GAEzCK,EAAWtB,EAASe,SAAmB,GAATE,EAAI,IAAQ,GAQ9C,IANiB,IAAbK,IACHA,EAAWtB,EAASW,YAKdU,EAAUC,GAEhB,GADAF,EAAIb,EAAKc,KACLD,EAAI,IAEP,IADAF,EAAOK,KAAKC,KAAKJ,EAAI,GAAKnB,EAAUY,EAAUG,GACvCH,EAAWK,EAAML,GAAYZ,EACnCW,EAAIC,GAAYN,EAAKc,UAGlB,GAAID,EAAI,IAGZ,IAFAD,EAAQZ,EAAKc,KACbH,EAAOK,KAAKC,KAAK,KAAW,IAAJJ,IAAanB,EAAUY,EAAUG,GAClDH,EAAWK,EAAML,GAAYZ,EACnCW,EAAIC,GAAYM,CAInB,CAED,OAAO,IAAIM,SAASpB,EAAS,EAAGF,EAAUF,EAC1C,CAgDQyB,CAAQ7B,EAAWC,GAE3B,GAAuB,IAAnBC,EACH,OAjDF,SAAkBF,EAAWG,GAC5B,MAAM,QAAEC,EAAF,KAAWC,GAASL,EACpB8B,EAAiC,EAAtBzB,EAAKE,eAChBC,EAAU,IAAIC,YAAYqB,EAAW1B,GACrCM,EAAO,IAAIC,WAAWR,EAASS,OAAQT,EAASU,WAAYV,EAASW,YACrEC,EAAM,IAAIJ,WAAWH,GAErBS,EAAcd,EAASe,SAAS,GAAG,GAEzC,IAAIO,EAAW,EACf,IAAK,IAAIL,EAAI,EAAGA,EAAIH,IAAeG,EAAG,CAErC,IAQIC,EACAC,EACAC,EAVAP,EADmB,IAANI,EAAU,EAAI,EAE3BI,EAAUrB,EAASe,SAAmB,GAATE,EAAI,IAAQ,GAU7C,IARAK,EAAWtB,EAASe,SAAmB,GAATE,EAAI,IAAQ,GAEzB,IAAbK,IACHA,EAAWtB,EAASW,YAKdU,EAAUC,GAEhB,GADAF,EAAIb,EAAKc,KACLD,EAAI,IAEP,IADAF,EAAOK,KAAKC,IAAc,GAATJ,EAAI,GAASP,EAAUc,GACjCd,EAAWK,EAAML,GAAY,EACnCD,EAAIC,GAAYN,EAAKc,UAGlB,GAAID,EAAI,IAGZ,IAFAD,EAAQZ,EAAKc,KACbH,EAAOK,KAAKC,IAAyB,GAApB,KAAW,IAAJJ,IAAiBP,EAAUc,GAC5Cd,EAAWK,EAAML,GAAY,EACnCD,EAAIC,GAAYM,CAInB,CACD,OAAO,IAAIM,SAASpB,EAAS,EAAGsB,EAAW1B,EAC3C,CAQQ2B,CAAS/B,EAAWC,GAG5B,MAAM,IAAI+B,MAAM,kCAChB,C","sources":["../../src/decoder/codecs/rle.js"],"sourcesContent":["/* eslint-disable no-bitwise */\n/* eslint-disable no-plusplus */\n\nfunction decode8(frameInfo, dataView) {\n\tconst { samples, size } = frameInfo;\n\tconst nPixels = size.numberOfPixels;\n\tconst decoded = new ArrayBuffer(nPixels * samples);\n\tconst data = new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength);\n\tconst out = new Uint8Array(decoded);\n\n\tlet outIndex = 0;\n\tconst numSegments = dataView.getInt32(0, true);\n\n\tconst endOfSegment = nPixels * numSegments;\n\n\tfor (let s = 0; s < numSegments; ++s) {\n\t\toutIndex = s;\n\n\t\tlet inIndex = dataView.getInt32((s + 1) * 4, true);\n\n\t\tlet maxIndex = dataView.getInt32((s + 2) * 4, true);\n\n\t\tif (maxIndex === 0) {\n\t\t\tmaxIndex = dataView.byteLength;\n\t\t}\n\t\tlet maxI;\n\t\tlet value;\n\t\tlet n;\n\t\twhile (inIndex < maxIndex) {\n\t\t\tn = data[inIndex++];\n\t\t\tif (n < 0x80) {\n\t\t\t\tmaxI = Math.min((n + 1) * samples + outIndex, endOfSegment);\n\t\t\t\tfor (; outIndex < maxI; outIndex += samples) {\n\t\t\t\t\tout[outIndex] = data[inIndex++];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (n > 0x80) {\n\t\t\t\tvalue = data[inIndex++];\n\t\t\t\tmaxI = Math.min((129 - (n ^ 0x80)) * samples + outIndex, endOfSegment);\n\t\t\t\tfor (; outIndex < maxI; outIndex += samples) {\n\t\t\t\t\tout[outIndex] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn new DataView(decoded, 0, nPixels * samples);\n}\n\nfunction decode16(frameInfo, dataView) {\n\tconst { samples, size } = frameInfo;\n\tconst outBytes = size.numberOfPixels * 2;\n\tconst decoded = new ArrayBuffer(outBytes * samples);\n\tconst data = new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength);\n\tconst out = new Uint8Array(decoded);\n\n\tconst numSegments = dataView.getInt32(0, true);\n\n\tlet maxIndex = 0;\n\tfor (let s = 0; s < numSegments; ++s) {\n\t\tconst highByte = s === 0 ? 1 : 0;\n\t\tlet outIndex = highByte;\n\t\tlet inIndex = dataView.getInt32((s + 1) * 4, true);\n\n\t\tmaxIndex = dataView.getInt32((s + 2) * 4, true);\n\n\t\tif (maxIndex === 0) {\n\t\t\tmaxIndex = dataView.byteLength;\n\t\t}\n\t\tlet maxI;\n\t\tlet value;\n\t\tlet n;\n\t\twhile (inIndex < maxIndex) {\n\t\t\tn = data[inIndex++];\n\t\t\tif (n < 0x80) {\n\t\t\t\tmaxI = Math.min((n + 1) * 2 + outIndex, outBytes);\n\t\t\t\tfor (; outIndex < maxI; outIndex += 2) {\n\t\t\t\t\tout[outIndex] = data[inIndex++];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (n > 0x80) {\n\t\t\t\tvalue = data[inIndex++];\n\t\t\t\tmaxI = Math.min((129 - (n ^ 0x80)) * 2 + outIndex, outBytes);\n\t\t\t\tfor (; outIndex < maxI; outIndex += 2) {\n\t\t\t\t\tout[outIndex] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn new DataView(decoded, 0, outBytes * samples);\n}\n\nfunction decode(frameInfo, pixelDataView) {\n\tconst { bytesAllocated } = frameInfo;\n\tif (bytesAllocated === 1) {\n\t\treturn decode8(frameInfo, pixelDataView);\n\t}\n\tif (bytesAllocated === 2) {\n\t\treturn decode16(frameInfo, pixelDataView);\n\t}\n\n\tthrow new Error(\"Unsupported data format for RLE\");\n}\n\nexport default decode;\n"],"names":["decode","frameInfo","pixelDataView","bytesAllocated","dataView","samples","size","nPixels","numberOfPixels","decoded","ArrayBuffer","data","Uint8Array","buffer","byteOffset","byteLength","out","outIndex","numSegments","getInt32","endOfSegment","s","maxI","value","n","inIndex","maxIndex","Math","min","DataView","decode8","outBytes","decode16","Error"],"sourceRoot":""}