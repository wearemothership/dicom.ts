{"version":3,"file":"static/js/998.b19e48ec.chunk.js","mappings":"8MA2BA,MAAMA,EAAa,CAACC,OAAQ,EAAGC,UAAW,EAAGC,SAAU,EAAGC,IAAK,EAAGC,KAAM,GAClEC,EAAa,WAEf,IAAIC,EAAY,IAAIC,WAAW,CAC3B,EACA,EAAG,EACH,GAAI,EAAG,EACP,EAAG,GAAI,GAAI,GACX,GAAI,GAAI,GAAI,GAAI,EAChB,EAAG,GAAI,GAAI,GAAI,GAAI,GACnB,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EACxB,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC3B,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GACxB,GAAI,GAAI,GAAI,GAAI,GAAI,GACpB,GAAI,GAAI,GAAI,GAAI,GAChB,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GACR,GAAI,GACJ,KAGAC,EAAU,KACVC,EAAU,IACVC,EAAU,KACVC,EAAU,KACVC,EAAU,KACVC,EAAU,KACVC,EAAW,KACXC,EAAa,KAEjB,SAASC,IACR,CAED,SAASC,EAAkBC,EAAaC,GAEpC,IADA,IAAsBC,EAAGC,EAArBC,EAAI,EAAGC,EAAO,GAAUC,EAAS,GAC9BA,EAAS,IAAMN,EAAYM,EAAS,IACvCA,IACJD,EAAKE,KAAK,CAACC,SAAU,GAAIC,MAAO,IAChC,IAAiBC,EAAbC,EAAIN,EAAK,GACb,IAAKH,EAAI,EAAGA,EAAII,EAAQJ,IAAK,CACzB,IAAKC,EAAI,EAAGA,EAAIH,EAAYE,GAAIC,IAAK,CAGjC,KAFAQ,EAAIN,EAAKO,OACPJ,SAASG,EAAEF,OAASR,EAAOG,GACtBO,EAAEF,MAAQ,GACbE,EAAIN,EAAKO,MAIb,IAFAD,EAAEF,QACFJ,EAAKE,KAAKI,GACHN,EAAKC,QAAUJ,GAClBG,EAAKE,KAAKG,EAAI,CAACF,SAAU,GAAIC,MAAO,IACpCE,EAAEH,SAASG,EAAEF,OAASC,EAAEF,SACxBG,EAAID,EAERN,GACH,CACGF,EAAI,EAAII,IAERD,EAAKE,KAAKG,EAAI,CAACF,SAAU,GAAIC,MAAO,IACpCE,EAAEH,SAASG,EAAEF,OAASC,EAAEF,SACxBG,EAAID,EAEX,CACD,OAAOL,EAAK,GAAGG,QAClB,CAED,SAASK,EAAqBC,EAAWC,EAAKC,GAC1C,OAAO,KAAOF,EAAUG,cAAgB,GAAKF,EAAMC,EACtD,CAED,SAASE,EAAWC,EAAMC,EACNC,EAAOC,EAAYC,EACnBC,EAAeC,EACfC,EAAgBC,GAIhC,IAAIC,EAAcP,EAAMO,YACpBC,EAAcR,EAAMQ,YAGpBC,EAAcV,EAAQW,EAAW,EAAGC,EAAY,EAEpD,SAASC,IACL,GAAID,EAAY,EAEZ,OADAA,IACQD,GAAYC,EAAa,EAGrC,GAAgB,MADhBD,EAAWZ,EAAKC,MACM,CAClB,IAAIc,EAAWf,EAAKC,KACpB,GAAIc,EACA,KAAM,uBAA0BH,GAAY,EAAKG,GAAUC,SAAS,GAG3E,CAED,OADAH,EAAY,EACLD,IAAa,CACvB,CAED,SAASK,EAAcC,GAGnB,IAFA,IACIC,EADAC,EAAOF,EAEkB,QAArBC,EAAML,MAAqB,CAE/B,GAAoB,kBADpBM,EAAOA,EAAKD,IAER,OAAOC,EACX,GAAoB,kBAATA,EACP,KAAM,0BACb,CACD,OAAO,IACV,CAED,SAASC,EAAQlC,GAEb,IADA,IAAImC,EAAI,EACDnC,EAAS,GAAG,CACf,IAAIgC,EAAML,IACV,GAAY,OAARK,EACA,OACJG,EAAKA,GAAK,EAAKH,EACfhC,GACH,CACD,OAAOmC,CACV,CAED,SAASC,EAAiBpC,GACtB,IAAImC,EAAID,EAAQlC,GAChB,OAAImC,GAAK,GAAMnC,EAAS,EACbmC,EACJA,IAAM,GAAKnC,GAAU,CAC/B,CAiCD,IAAIqC,EAAS,EAyBb,IAA2BC,EAAvBC,EAAoB,EA0DxB,SAASC,EAAUhC,EAAWiC,EAAQC,EAAKjC,EAAKC,GAC5C,IACIiC,EAASD,EAAMpB,EAInBmB,EAAOjC,EADMD,EAAqBC,GAJpBkC,EAAMpB,EAAe,GAEXd,EAAUoC,EAAInC,EACvBkC,EAASnC,EAAUqC,EAAInC,GAGzC,CAED,SAASoC,EAAYtC,EAAWiC,EAAQC,GAIpCD,EAAOjC,EADMD,EAAqBC,EAFlBkC,EAAMlC,EAAUG,cAAiB,EAClC+B,EAAMlC,EAAUG,eAGlC,CAED,IACIH,EAAWZ,EAAGC,EAAGC,EAAGqC,EACpBY,EAFAC,EAAmBhC,EAAWhB,OAK1B+C,EAFJxB,EACsB,IAAlBL,EAC8B,IAAnBE,EAlHnB,SAAuBZ,EAAWM,GAC9B,IAAImC,EAAInB,EAActB,EAAU0C,gBAC5BC,EAAa,IAANF,EAAU,EAAKb,EAAiBa,IAAM5B,EACjDb,EAAU4C,UAAUtC,GAAWN,EAAU6C,MAAQF,CACpD,EAED,SAA4B3C,EAAWM,GACnCN,EAAU4C,UAAUtC,IAAWa,KAAaN,CAC/C,EA4GqC,IAAnBD,EAzGnB,SAAuBZ,EAAWM,GAC9B,GAAIuB,EAAS,EACTA,SAIJ,IADA,IAAIvC,EAAIoB,EAAeoC,EAAInC,EACpBrB,GAAKwD,GAAG,CACX,IAAIC,EAAKzB,EAActB,EAAUgD,gBAC7BC,EAAS,GAALF,EAASG,EAAIH,GAAM,EAC3B,GAAU,IAANE,EAAJ,CASA,IAAIE,EAAI7E,EADRgB,GAAK4D,GAELlD,EAAU4C,UAAUtC,EAAS6C,GAAKvB,EAAiBqB,IAAM,GAAKpC,GAC9DvB,GAJC,KAPD,CACI,GAAI4D,EAAI,GAAI,CACRrB,EAASH,EAAQwB,IAAM,GAAKA,GAAK,EACjC,KACH,CACD5D,GAAK,EAER,CAKJ,CACJ,EAGD,SAA4BU,EAAWM,GAEnC,IADA,IAAIhB,EAAIoB,EAAeoC,EAAInC,EAAauC,EAAI,EACrC5D,GAAKwD,GAAG,CACX,IAAIK,EAAI7E,EAAUgB,GAClB,OAAQyC,GACJ,KAAK,EACD,IAAIgB,EAAKzB,EAActB,EAAUgD,gBAC7BC,EAAS,GAALF,EAER,GADAG,EAAIH,GAAM,EACA,IAANE,EACIC,EAAI,IACJrB,EAASH,EAAQwB,IAAM,GAAKA,GAC5BnB,EAAoB,IAEpBmB,EAAI,GACJnB,EAAoB,OAErB,CACH,GAAU,IAANkB,EACA,KAAM,uBACVnB,EAAwBF,EAAiBqB,GACzClB,EAAoBmB,EAAI,EAAI,CAC/B,CACD,SACJ,KAAK,EACL,KAAK,EACGlD,EAAU4C,UAAUtC,EAAS6C,GAC7BnD,EAAU4C,UAAUtC,EAAS6C,IAAOhC,KAAaN,EAGvC,MADVqC,IAEInB,EAAyC,GAArBA,EAAyB,EAAI,GAEzD,MACJ,KAAK,EACG/B,EAAU4C,UAAUtC,EAAS6C,GAC7BnD,EAAU4C,UAAUtC,EAAS6C,IAAOhC,KAAaN,GAEjDb,EAAU4C,UAAUtC,EAAS6C,GAAKrB,GAAyBjB,EAC3DkB,EAAoB,GAExB,MACJ,KAAK,EACG/B,EAAU4C,UAAUtC,EAAS6C,KAC7BnD,EAAU4C,UAAUtC,EAAS6C,IAAOhC,KAAaN,GAI7DvB,GACH,CACyB,IAAtByC,GAEe,MADfF,IAEIE,EAAoB,EAE/B,EAhHD,SAAwB/B,EAAWM,GAC/B,IAAImC,EAAInB,EAActB,EAAU0C,gBAC5BC,EAAa,IAANF,EAAU,EAAIb,EAAiBa,GAC1CzC,EAAU4C,UAAUtC,GAAWN,EAAU6C,MAAQF,EAEjD,IADA,IAAIrD,EAAI,EACDA,EAAI,IAAI,CACX,IAAIyD,EAAKzB,EAActB,EAAUgD,gBAC7BC,EAAS,GAALF,EAASG,EAAIH,GAAM,EAC3B,GAAU,IAANE,EAAJ,CAOA,IAAIE,EAAI7E,EADRgB,GAAK4D,GAELlD,EAAU4C,UAAUtC,EAAS6C,GAAKvB,EAAiBqB,GACnD3D,GAJC,KALD,CACI,GAAI4D,EAAI,GACJ,MACJ5D,GAAK,EAER,CAKJ,CACJ,EA2HD,IAAa8D,EACTC,EAUAhB,EAAGD,EAXHF,EAAM,EAYV,IATImB,EADoB,GAApBb,EACchC,EAAW,GAAGL,cAAgBK,EAAW,GAAG8C,gBAE5CxC,EAAcP,EAAMgD,cAEjC9C,IACDA,EAAgB4C,GAIbnB,EAAMmB,GAAa,CAEtB,IAAKjE,EAAI,EAAGA,EAAIoD,EAAkBpD,IAC9BoB,EAAWpB,GAAGyD,KAAO,EAIzB,GAFAhB,EAAS,EAEe,GAApBW,EAEA,IADAxC,EAAYQ,EAAW,GAClBmB,EAAI,EAAGA,EAAIlB,EAAekB,IAC3BW,EAAYtC,EAAWuC,EAAUL,GACjCA,SAGJ,IAAKP,EAAI,EAAGA,EAAIlB,EAAekB,IAAK,CAChC,IAAKvC,EAAI,EAAGA,EAAIoD,EAAkBpD,IAI9B,IAFAiD,GADArC,EAAYQ,EAAWpB,IACTiD,EACdD,EAAIpC,EAAUoC,EACT/C,EAAI,EAAGA,EAAI+C,EAAG/C,IACf,IAAKC,EAAI,EAAGA,EAAI+C,EAAG/C,IACf0C,EAAUhC,EAAWuC,EAAUL,EAAK7C,EAAGC,GAInD4C,GACH,CAML,GAFAhB,EAAY,GACZkC,EAAU/C,EAAKC,IAAW,EAAKD,EAAKC,EAAS,KAC/B,MACV,KAAM,uBAGV,KAAI8C,GAAU,OAAUA,GAAU,OAG9B,MAFA9C,GAAU,CAIjB,CAED,OAAOA,EAASU,CAvUgB,CA+UpC,SAASwC,EAAmBxD,EAAWyD,EAAmB5D,GACtD,IACI6D,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIxB,EAChCrD,EAFA8E,EAAKlE,EAAUmE,kBAKnB,IAAK/E,EAAI,EAAGA,EAAI,GAAIA,IAChBS,EAAET,GAAKY,EAAU4C,UAAUa,EAAoBrE,GAAK8E,EAAG9E,GAI3D,IAAKA,EAAI,EAAGA,EAAI,IAAKA,EAAG,CACpB,IAAIa,EAAM,EAAIb,EAGK,IAAfS,EAAE,EAAII,IAA6B,IAAfJ,EAAE,EAAII,IAA6B,IAAfJ,EAAE,EAAII,IAC/B,IAAfJ,EAAE,EAAII,IAA6B,IAAfJ,EAAE,EAAII,IAA6B,IAAfJ,EAAE,EAAII,IAC/B,IAAfJ,EAAE,EAAII,IAcVyD,EAAM5E,EAAWe,EAAE,EAAII,GAAO,KAAQ,EACtC0D,EAAM7E,EAAWe,EAAE,EAAII,GAAO,KAAQ,EACtC2D,EAAK/D,EAAE,EAAII,GACX4D,EAAKhE,EAAE,EAAII,GACX6D,EAAM/E,GAAcc,EAAE,EAAII,GAAOJ,EAAE,EAAII,IAAQ,KAAQ,EACvDgE,EAAMlF,GAAcc,EAAE,EAAII,GAAOJ,EAAE,EAAII,IAAQ,KAAQ,EACvD8D,EAAKlE,EAAE,EAAII,IAAQ,EACnB+D,EAAKnE,EAAE,EAAII,IAAQ,EAGnBwC,EAAKiB,EAAKC,EAAK,GAAM,EACrBD,EAAMA,EAAKC,EAAK,GAAM,EACtBA,EAAKlB,EACLA,EAAKmB,EAAK/E,EAAUgF,EAAKjF,EAAU,KAAQ,EAC3CgF,EAAMA,EAAKhF,EAAUiF,EAAKhF,EAAU,KAAQ,EAC5CgF,EAAKpB,EACLA,EAAKqB,EAAKE,EAAK,GAAM,EACrBF,EAAMA,EAAKE,EAAK,GAAM,EACtBA,EAAKvB,EACLA,EAAKwB,EAAKF,EAAK,GAAM,EACrBA,EAAME,EAAKF,EAAK,GAAM,EACtBE,EAAKxB,EAGLA,EAAKiB,EAAKG,EAAK,GAAM,EACrBH,EAAMA,EAAKG,EAAK,GAAM,EACtBA,EAAKpB,EACLA,EAAKkB,EAAKC,EAAK,GAAM,EACrBD,EAAMA,EAAKC,EAAK,GAAM,EACtBA,EAAKnB,EACLA,EAAKqB,EAAKnF,EAAUsF,EAAKvF,EAAU,MAAS,GAC5CoF,EAAMA,EAAKpF,EAAUuF,EAAKtF,EAAU,MAAS,GAC7CsF,EAAKxB,EACLA,EAAKsB,EAAKtF,EAAUuF,EAAKxF,EAAU,MAAS,GAC5CuF,EAAMA,EAAKvF,EAAUwF,EAAKvF,EAAU,MAAS,GAC7CuF,EAAKvB,EAGL5C,EAAE,EAAII,GAAOyD,EAAKO,EAClBpE,EAAE,EAAII,GAAOyD,EAAKO,EAClBpE,EAAE,EAAII,GAAO0D,EAAKK,EAClBnE,EAAE,EAAII,GAAO0D,EAAKK,EAClBnE,EAAE,EAAII,GAAO2D,EAAKG,EAClBlE,EAAE,EAAII,GAAO2D,EAAKG,EAClBlE,EAAE,EAAII,GAAO4D,EAAKC,EAClBjE,EAAE,EAAII,GAAO4D,EAAKC,IA1DdrB,EAAK3D,EAAWe,EAAE,EAAII,GAAO,KAAQ,GACrCJ,EAAE,EAAII,GAAOwC,EACb5C,EAAE,EAAII,GAAOwC,EACb5C,EAAE,EAAII,GAAOwC,EACb5C,EAAE,EAAII,GAAOwC,EACb5C,EAAE,EAAII,GAAOwC,EACb5C,EAAE,EAAII,GAAOwC,EACb5C,EAAE,EAAII,GAAOwC,EACb5C,EAAE,EAAII,GAAOwC,EA1BoC,CAgFzD,IAAKrD,EAAI,EAAGA,EAAI,IAAKA,EAAG,CACpB,IAAIc,EAAMd,EAGa,IAAnBS,EAAE,EAAQK,IAAiC,IAAnBL,EAAE,GAAQK,IAAiC,IAAnBL,EAAE,GAAQK,IACvC,IAAnBL,EAAE,GAAQK,IAAiC,IAAnBL,EAAE,GAAQK,IAAiC,IAAnBL,EAAE,GAAQK,IACvC,IAAnBL,EAAE,GAAQK,IAcdwD,EAAM5E,EAAWe,EAAE,EAAQK,GAAO,MAAS,GAC3CyD,EAAM7E,EAAWe,EAAE,GAAQK,GAAO,MAAS,GAC3C0D,EAAK/D,EAAE,GAAQK,GACf2D,EAAKhE,EAAE,GAAQK,GACf4D,EAAM/E,GAAcc,EAAE,EAAQK,GAAOL,EAAE,GAAQK,IAAQ,MAAS,GAChE+D,EAAMlF,GAAcc,EAAE,EAAQK,GAAOL,EAAE,GAAQK,IAAQ,MAAS,GAChE6D,EAAKlE,EAAE,GAAQK,GACf8D,EAAKnE,EAAE,GAAQK,GAGfuC,EAAKiB,EAAKC,EAAK,GAAM,EACrBD,EAAMA,EAAKC,EAAK,GAAM,EACtBA,EAAKlB,EACLA,EAAKmB,EAAK/E,EAAUgF,EAAKjF,EAAU,MAAS,GAC5CgF,EAAMA,EAAKhF,EAAUiF,EAAKhF,EAAU,MAAS,GAC7CgF,EAAKpB,EACLA,EAAKqB,EAAKE,EAAK,GAAM,EACrBF,EAAMA,EAAKE,EAAK,GAAM,EACtBA,EAAKvB,EACLA,EAAKwB,EAAKF,EAAK,GAAM,EACrBA,EAAME,EAAKF,EAAK,GAAM,EACtBE,EAAKxB,EAGLA,EAAKiB,EAAKG,EAAK,GAAM,EACrBH,EAAMA,EAAKG,EAAK,GAAM,EACtBA,EAAKpB,EACLA,EAAKkB,EAAKC,EAAK,GAAM,EACrBD,EAAMA,EAAKC,EAAK,GAAM,EACtBA,EAAKnB,EACLA,EAAKqB,EAAKnF,EAAUsF,EAAKvF,EAAU,MAAS,GAC5CoF,EAAMA,EAAKpF,EAAUuF,EAAKtF,EAAU,MAAS,GAC7CsF,EAAKxB,EACLA,EAAKsB,EAAKtF,EAAUuF,EAAKxF,EAAU,MAAS,GAC5CuF,EAAMA,EAAKvF,EAAUwF,EAAKvF,EAAU,MAAS,GAC7CuF,EAAKvB,EAGL5C,EAAE,EAAQK,GAAOwD,EAAKO,EACtBpE,EAAE,GAAQK,GAAOwD,EAAKO,EACtBpE,EAAE,EAAQK,GAAOyD,EAAKK,EACtBnE,EAAE,GAAQK,GAAOyD,EAAKK,EACtBnE,EAAE,GAAQK,GAAO0D,EAAKG,EACtBlE,EAAE,GAAQK,GAAO0D,EAAKG,EACtBlE,EAAE,GAAQK,GAAO2D,EAAKC,EACtBjE,EAAE,GAAQK,GAAO2D,EAAKC,IA1DlBrB,EAAK3D,EAAWe,EAAET,EAAI,GAAK,MAAS,GACpCS,EAAE,EAAQK,GAAOuC,EACjB5C,EAAE,EAAQK,GAAOuC,EACjB5C,EAAE,GAAQK,GAAOuC,EACjB5C,EAAE,GAAQK,GAAOuC,EACjB5C,EAAE,GAAQK,GAAOuC,EACjB5C,EAAE,GAAQK,GAAOuC,EACjB5C,EAAE,GAAQK,GAAOuC,EACjB5C,EAAE,GAAQK,GAAOuC,EA/FgC,CAqJzD,IAAKrD,EAAI,EAAGA,EAAI,KAAMA,EAAG,CACrB,IAAIO,EAAQ8D,EAAoBrE,EAC5BQ,EAAIC,EAAET,GACVQ,EAAKA,IAAM,KAAOI,EAAUoE,cAAiB,EACxCxE,GAAK,KAAOI,EAAUoE,cAAiB,IAAMpE,EAAUoE,cACvDxE,EAAI,KAAOI,EAAUoE,eAAkB,EAC5CpE,EAAU4C,UAAUjD,GAASC,CAChC,CACJ,CAED,SAASyE,EAAmB9D,EAAOP,GAQ/B,IANA,IAAIG,EAAgBH,EAAUG,cAC1BmD,EAAkBtD,EAAUsD,gBAE5BgB,EAAoB,IAAI/F,WAAW,IAG9BgG,EAAW,EAAGA,EAAWjB,EAAiBiB,IAC/C,IAAK,IAAIC,EAAW,EAAGA,EAAWrE,EAAeqE,IAAY,CAEzDhB,EAAmBxD,EADND,EAAqBC,EAAWuE,EAAUC,GACjBF,EACzC,CAEL,OAAOtE,EAAU4C,SACpB,CAED,SAAS6B,EAAaC,GAClB,OAAOA,GAAK,EAAI,EAAIA,GAAK,IAAM,IAAU,EAAJA,CACxC,CA6dD,OA3dA1F,EAAY2F,UAAY,CACpBC,KAAM,SAAcC,GAChB,IAAIC,EAAc,SAAUzE,GACxB0E,KAAKC,MAAM3E,GACP0E,KAAKE,QACLF,KAAKE,QAHI,EAIdC,KAAKH,MAER,GAAIF,EAAKM,QAAQ,UAAY,EAAG,CAI5B,IAHA,IAAI7E,EAASuE,EAAKM,QAAQ,WAAa,EACnC9E,EAAO+E,KAAKP,EAAKQ,UAAU/E,IAC3BgF,EAAM,IAAIC,WAAWlF,EAAKb,QACrBJ,EAAIiB,EAAKb,OAAS,EAAGJ,GAAK,EAAGA,IAClCkG,EAAIlG,GAAKiB,EAAKmF,WAAWpG,GAE7B0F,EAAWzE,EAPf,KAQO,CACH,IAAIoF,EAAM,IAAIC,eACdD,EAAIE,KAAK,MAAOd,GAAM,GACtBY,EAAIG,aAAe,cACnBH,EAAIR,OAAU,WAEV,IAAI5E,EAAO,IAAIkF,WAAWE,EAAII,UAC9Bf,EAAWzE,EAHF,EAIV6E,KAAKH,MACRU,EAAIK,KAAK,KACZ,CA1Be,EA4BpBd,MAAO,SAAe3E,GAElB,SAAS0F,IACL,IAAIC,EAAS3F,EAAKC,IAAW,EAAKD,EAAKC,EAAS,GAEhD,OADAA,GAAU,EACH0F,CACV,CAED,SAASC,IACL,IAAIzG,EAASuG,IACTG,EAAQ7F,EAAK8F,SAAS7F,EAAQA,EAASd,EAAS,GAEpD,OADAc,GAAU4F,EAAM1G,OACT0G,CACV,CAED,SAASE,EAAkB7F,GAGvB,IAFA,IAAIO,EAAcuF,KAAKC,KAAK/F,EAAMgG,eAAiB,EAAIhG,EAAMiG,MACzDjD,EAAgB8C,KAAKC,KAAK/F,EAAMkG,UAAY,EAAIlG,EAAMmG,MACjDtH,EAAI,EAAGA,EAAImB,EAAMC,WAAWhB,OAAQJ,IAAK,CAC9CY,EAAYO,EAAMC,WAAWpB,GAC7B,IAAIe,EAAgBkG,KAAKC,KAAKD,KAAKC,KAAK/F,EAAMgG,eAAiB,GAAKvG,EAAUqC,EAAI9B,EAAMiG,MACpFlD,EAAkB+C,KAAKC,KAAKD,KAAKC,KAAK/F,EAAMkG,UAAY,GAAKzG,EAAUoC,EAAI7B,EAAMmG,MACjFC,EAAsB7F,EAAcd,EAAUqC,EAG9CuE,EAAmB,IAFKrD,EAAgBvD,EAAUoC,IAEDuE,EAAsB,GAC3E3G,EAAU4C,UAAY,IAAIiE,WAAWD,GACrC5G,EAAUG,cAAgBA,EAC1BH,EAAUsD,gBAAkBA,CAC/B,CACD/C,EAAMO,YAAcA,EACpBP,EAAMgD,cAAgBA,CACzB,CAEGjD,IAIAC,EAAOE,EAJPH,EAAS,EACTwG,EAAO,KACPC,EAAQ,KAGRC,EAAqB,GACrBC,EAAkB,GAAIC,EAAkB,GACxCC,EAAapB,IACjB,GAAkB,OAAdoB,EACA,KAAM,gBAIV,IADAA,EAAapB,IACQ,OAAdoB,GAAsB,CACzB,IAAO9H,EAAG+H,EACV,OAAQD,GACJ,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACD,IAAIE,EAAUpB,IAEK,QAAfkB,GACmB,KAAfE,EAAQ,IAA8B,KAAfA,EAAQ,IAA8B,KAAfA,EAAQ,IACvC,KAAfA,EAAQ,IAA8B,IAAfA,EAAQ,KAC/BP,EAAO,CACHQ,QAAS,CAACC,MAAOF,EAAQ,GAAIG,MAAOH,EAAQ,IAC5CI,aAAcJ,EAAQ,GACtBK,SAAWL,EAAQ,IAAM,EAAKA,EAAQ,GACtCM,SAAWN,EAAQ,KAAO,EAAKA,EAAQ,IACvCO,WAAYP,EAAQ,IACpBQ,YAAaR,EAAQ,IACrBS,UAAWT,EAAQlB,SAAS,GAAI,GAAK,EAAIkB,EAAQ,IAAMA,EAAQ,OAKxD,QAAfF,GACmB,KAAfE,EAAQ,IAA8B,MAAfA,EAAQ,IAA8B,MAAfA,EAAQ,IACvC,KAAfA,EAAQ,IAA8B,MAAfA,EAAQ,IAA8B,IAAfA,EAAQ,KACtDN,EAAQ,CACJO,QAASD,EAAQ,GACjBU,OAASV,EAAQ,IAAM,EAAKA,EAAQ,GACpCW,OAASX,EAAQ,IAAM,EAAKA,EAAQ,IACpCY,cAAeZ,EAAQ,MAInC,MAEJ,KAAK,MAGD,IAFA,IACIa,EAD2BnC,IACwBzF,EAAS,EACzDA,EAAS4H,GAAuB,CACnC,IAAIC,EAAwB9H,EAAKC,KAC7B8H,EAAY,IAAI7J,WAAW,IAC/B,GAAK4J,GAAyB,IAAO,EACjC,IAAK9I,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAErB+I,EADQ9J,EAAUe,IACHgB,EAAKC,IACvB,KACE,IAAK6H,GAAyB,IAAO,EAMxC,KAAM,0BALN,IAAK9I,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAErB+I,EADS9J,EAAUe,IACH0G,GACnB,CAED,CACJiB,EAA2C,GAAxBmB,GAA8BC,CACpD,CACD,MAEJ,KAAK,MACL,KAAK,MACL,KAAK,MACD,GAAI7H,EACA,KAAM,oCAEVwF,KACAxF,EAAQ,CAAC,GACH8H,SAA2B,QAAflB,EAClB5G,EAAMQ,YAA8B,QAAfoG,EACrB5G,EAAM+H,UAAYjI,EAAKC,KACvBC,EAAMkG,UAAYV,IAClBxF,EAAMgG,eAAiBR,IACvBxF,EAAMC,WAAa,GACnBD,EAAMgI,aAAe,CAAC,EACtB,IAAsCC,EAAlCC,EAAkBpI,EAAKC,KACvBkG,EAAO,EAAGE,EAAO,EACrB,IAAKtH,EAAI,EAAGA,EAAIqJ,EAAiBrJ,IAAK,CAClCoJ,EAAcnI,EAAKC,GACnB,IAAI+B,EAAIhC,EAAKC,EAAS,IAAM,EACxB8B,EAAuB,GAAnB/B,EAAKC,EAAS,GAClBkG,EAAOnE,IACPmE,EAAOnE,GACPqE,EAAOtE,IACPsE,EAAOtE,GACX,IAAIsG,EAAMrI,EAAKC,EAAS,GACxB8G,EAAI7G,EAAMC,WAAWf,KAAK,CACtB4C,EAAGA,EACHD,EAAGA,EACH+B,kBAAmB6C,EAAmB0B,GACtCC,oBAAqBD,EACrBtE,cAAe,MAAQ,GAAK7D,EAAM+H,WAAa,KAEnD/H,EAAMgI,aAAaC,GAAepB,EAAI,EACtC9G,GAAU,CACb,CACDC,EAAMiG,KAAOA,EACbjG,EAAMmG,KAAOA,EACbN,EAAkB7F,GAClB,MAEJ,KAAK,MACD,IAAIqI,EAAgB7C,IACpB,IAAK3G,EAAI,EAAGA,EAAIwJ,GAAiB,CAC7B,IAAIC,EAAmBxI,EAAKC,KACxBpB,EAAc,IAAIqG,WAAW,IAC7BuD,EAAgB,EACpB,IAAKzJ,EAAI,EAAGA,EAAI,GAAIA,IAAKiB,IACrBwI,GAAkB5J,EAAYG,GAAKgB,EAAKC,GAC5C,IAAIyI,EAAgB,IAAIxD,WAAWuD,GACnC,IAAKzJ,EAAI,EAAGA,EAAIyJ,EAAezJ,IAAKiB,IAChCyI,EAAc1J,GAAKgB,EAAKC,GAC5BlB,GAAK,GAAK0J,GAERD,GAAoB,IAAO,EACzB3B,EAAkBD,GAAoC,GAAnB4B,GACnC5J,EAAkBC,EAAa6J,EACtC,CACD,MAEJ,KAAK,MACDhD,IACAtF,EAAgBsF,IAChB,MAEJ,KAAK,MACgBA,IACjB,IAAIiD,EAAiB3I,EAAKC,KACtBE,EAAa,GACjB,IAAKpB,EAAI,EAAGA,EAAI4J,EAAgB5J,IAAK,CACjC,IAAI6J,EAAiB1I,EAAMgI,aAAalI,EAAKC,MAC7CN,EAAYO,EAAMC,WAAWyI,GAC7B,IAAIC,EAAY7I,EAAKC,KACrBN,EAAU0C,eAAiBwE,EAAgBgC,GAAa,GACxDlJ,EAAUgD,eAAiBiE,EAA4B,GAAZiC,GAC3C1I,EAAWf,KAAKO,EACnB,CACD,IAAIU,EAAgBL,EAAKC,KACrBK,EAAcN,EAAKC,KACnB6I,EAA0B9I,EAAKC,KAC/B8I,EAAYhJ,EAAWC,EAAMC,EAC7BC,EAAOC,EAAYC,EACnBC,EAAeC,EACfwI,GAA2B,EAA6B,GAA1BA,GAClC7I,GAAU8I,EACV,MAEJ,KAAK,MACoB,MAAjB/I,EAAKC,IACLA,IAEJ,MAEJ,QACI,GAAwB,KAApBD,EAAKC,EAAS,IACdD,EAAKC,EAAS,IAAM,KAAQD,EAAKC,EAAS,IAAM,IAAM,CAGtDA,GAAU,EACV,KACH,CACD,KAAM,uBAAyB6G,EAAW9F,SAAS,IAE3D8F,EAAapB,GAChB,CAOD,OALAhB,KAAKsE,MAAQ9I,EAAMgG,eACnBxB,KAAKuE,OAAS/I,EAAMkG,UACpB1B,KAAK+B,KAAOA,EACZ/B,KAAKgC,MAAQA,EACbhC,KAAKvE,WAAa,GACVD,EAAMC,WAAWhB,QAErB,KAAK,EACDuF,KAAKwE,WAAaxL,EAAWE,UAC7B,MACJ,KAAK,EACG8G,KAAKgC,MACLhC,KAAKwE,WAAaxL,EAAWG,SAE7B6G,KAAKwE,WAAaxL,EAAWI,IACjC,MACJ,KAAK,EACD4G,KAAKwE,WAAaxL,EAAWK,KAC7B,MACJ,QACI2G,KAAKwE,WAAaxL,EAAWyL,QAErC,IAAK,IAAIpK,EAAI,EAAGA,EAAImB,EAAMC,WAAWhB,OAAQJ,IAAK,CAC9C,IAAIY,KAAYO,EAAMC,WAAWpB,IAClB+E,mBAAuD,OAAlCnE,EAAU2I,sBAC1C3I,EAAUmE,kBAAoB6C,EAAmBhH,EAAU2I,sBAC/D5D,KAAKvE,WAAWf,KAAK,CACjBgK,OAAQpF,EAAmB9D,EAAOP,GAClC0J,OAAQ1J,EAAUqC,EAAI9B,EAAMiG,KAC5BmD,OAAQ3J,EAAUoC,EAAI7B,EAAMmG,KAC5BvG,cAAeH,EAAUG,cACzBmD,gBAAiBtD,EAAUsD,gBAC3Bc,cAAepE,EAAUoE,eAEhC,CA/Re,EAiSpBwF,UAAW,SAAmBP,EAAOC,GACjC,GAA+B,IAA3BvE,KAAKvE,WAAWhB,OAChB,KAAM,yBACV,IAEIQ,EAAW6J,EAAiBC,EAC5BC,EAAGC,EAAG5K,EAHNsK,EAAS3E,KAAKsE,MAAQA,EAAOM,EAAS5E,KAAKuE,OAASA,EAIpDhJ,EAAS,EACT2J,EAAgBlF,KAAKvE,WAAWhB,OAEhCa,EAAO,IAAI6J,YADEb,EAAQC,EAASW,GAM9BE,EAAW,IAAID,aAAanF,KAAKvE,WAAW,GAAGL,eAAiB,GAChE4E,KAAKvE,WAAW,GAAG8C,gBAAkB,GAGzC,IAAKlE,EAAI,EAAGA,EAAI6K,EAAe7K,IAAK,CAQhC,IANA,IAIIC,EAAGC,EAsBHK,EA1BAQ,GADJH,EAAY+E,KAAKvE,WAAWpB,IACEe,cAC1BmD,EAAkBtD,EAAUsD,gBAC5BiD,EAAiBpG,GAAiB,EAGlCiK,EAAa,EACR7F,EAAW,EAAGA,EAAWjB,EAAiBiB,IAE/C,IADA,IAAI8F,EAAW9F,GAAY,EAClBC,EAAW,EAAGA,EAAWrE,EAAeqE,IAAY,CACzD,IAAI8F,EAAevK,EAAqBC,EAAWuE,EAAUC,GAC7C+F,GAAZjK,EAAS,EAAYkE,GAAY,GACrC,IAAKnF,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAChB+K,GAAcC,EAAWhL,GAAKkH,EAClC,IAAKjH,EAAI,EAAGA,EAAI,EAAGA,IACf6K,EAASC,EAAaG,EAASjL,GAC3BU,EAAUyJ,OAAOa,EAAehK,IAE3C,CACJ,CASL,IANAuJ,EAAkB7J,EAAU0J,OAASA,EACrCI,EAAkB9J,EAAU2J,OAASA,EACrCrJ,EAASlB,EAIJ4K,EAAI,EAAGA,EAAIV,EAAQU,IACpB,IAAKD,EAAI,EAAGA,EAAIV,EAAOU,IAGnBpK,GAFK,EAAKqK,EAAIF,GAEDvD,GADR,EAAKwD,EAAIF,GAEdxJ,EAAKC,GAAU6J,EAASxK,GACxBW,GAAU2J,CAGrB,CACD,OAAO5J,CA3VS,EA6VpBmK,QAAS,SAAiBnB,EAAOC,GAC7B,IAEItJ,EAAW6J,EAAiBC,EAC5BC,EAAGC,EAAG5K,EAENqL,EAAGC,EAAIC,EAAOC,EAAGC,EAAOC,EAAGC,EAAGC,EAC9BC,EANAvB,EAAS3E,KAAKsE,MAAQA,EAAOM,EAAS5E,KAAKuE,OAASA,EAIpDhJ,EAAS,EAGT2J,EAAgBlF,KAAKvE,WAAWhB,OAChC0L,EAAa7B,EAAQC,EAASW,EAC9B5J,EAAO,IAAIkF,WAAW2F,GAKtBf,EAAW,IAAI5E,YAAYR,KAAKvE,WAAW,GAAGL,eAAiB,GAC/D4E,KAAKvE,WAAW,GAAG8C,gBAAkB,GAGzC,IAAKlE,EAAI,EAAGA,EAAI6K,EAAe7K,IAAK,CAQhC,IANA,IAIIC,EAAGC,EAsBHK,EA1BAQ,GADJH,EAAY+E,KAAKvE,WAAWpB,IACEe,cAC1BmD,EAAkBtD,EAAUsD,gBAC5BiD,EAAiBpG,GAAiB,EAGlCiK,EAAa,EACR7F,EAAW,EAAGA,EAAWjB,EAAiBiB,IAE/C,IADA,IAAI8F,EAAW9F,GAAY,EAClBC,EAAW,EAAGA,EAAWrE,EAAeqE,IAAY,CACzD,IAAI8F,EAAevK,EAAqBC,EAAWuE,EAAUC,GAC7C+F,GAAZjK,EAAS,EAAYkE,GAAY,GACrC,IAAKnF,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAChB+K,GAAcC,EAAWhL,GAAKkH,EAClC,IAAKjH,EAAI,EAAGA,EAAI,EAAGA,IACf6K,EAASC,EAAaG,EAASjL,GAC3BU,EAAUyJ,OAAOa,EAAehK,KAAYN,EAAUoE,aAEjE,CACJ,CASL,IANAyF,EAAkB7J,EAAU0J,OAASA,EACrCI,EAAkB9J,EAAU2J,OAASA,EACrCrJ,EAASlB,EAIJ4K,EAAI,EAAGA,EAAIV,EAAQU,IACpB,IAAKD,EAAI,EAAGA,EAAIV,EAAOU,IAGnBpK,GAFK,EAAKqK,EAAIF,GAEDvD,GADR,EAAKwD,EAAIF,GAEdxJ,EAAKC,GAAU6J,EAASxK,GACxBW,GAAU2J,CAtDe,CA4DrC,OAAQA,GACJ,KAAK,EACL,KAAK,EACD,MAGJ,KAAK,EASD,GAPAgB,GAAiB,EAEblG,KAAKgC,OAAShC,KAAKgC,MAAMkB,cACzBgD,GAAiB,EACmB,qBAAxBlG,KAAKkG,iBACjBA,IAAmBlG,KAAKkG,gBAExBA,EACA,IAAK7L,EAAI,EAAGA,EAAI8L,EAAY9L,GAAK6K,EAC7BQ,EAAIpK,EAAKjB,GACTsL,EAAKrK,EAAKjB,EAAI,GAGd0L,EAAIrG,EAAagG,EAAI,QAAU,OAF/BE,EAAKtK,EAAKjB,EAAI,KAGd2L,EAAItG,EAAagG,EAAI,QAAU,KAAQC,EAAK,KAAQC,GACpDK,EAAIvG,EAAagG,EAAI,QAAU,MAAQC,GAEvCrK,EAAKjB,GAAS0L,EACdzK,EAAKjB,EAAI,GAAK2L,EACd1K,EAAKjB,EAAI,GAAK4L,EAGtB,MACJ,KAAK,EACD,IAAKjG,KAAKgC,MACN,KAAM,wCASV,GAPAkE,GAAiB,EAEblG,KAAKgC,OAAShC,KAAKgC,MAAMkB,cACzBgD,GAAiB,EACmB,qBAAxBlG,KAAKkG,iBACjBA,IAAmBlG,KAAKkG,gBAExBA,EACA,IAAK7L,EAAI,EAAGA,EAAI8L,EAAY9L,GAAK6K,EAC7BQ,EAAIpK,EAAKjB,GACTsL,EAAKrK,EAAKjB,EAAI,GAGdwL,EAAInG,EAAa,QAAUgG,EAAI,OAF/BE,EAAKtK,EAAKjB,EAAI,KAGdyL,EAAIpG,EAAa,QAAUgG,EAAI,KAAQC,EAAK,KAAQC,GACpDF,EAAIhG,EAAa,QAAUgG,EAAI,MAAQC,GAEvCrK,EAAKjB,GAASwL,EACdvK,EAAKjB,EAAI,GAAKyL,EACdxK,EAAKjB,EAAI,GAAKqL,EAItB,MACJ,QACI,KAAM,yBAEd,OAAOpK,CACV,GAGErB,CA99BO,CAAC,E","sources":["../../src/decoder/codecs/jpeg-baseline.js"],"sourcesContent":["/*\n Copyright 2011 notmasteryet\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n */\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\n/* istanbul ignore file */\n\n/* eslint-disable */\nconst ColorSpace = {Unkown: 0, Grayscale: 1, AdobeRGB: 2, RGB: 3, CYMK: 4};\nconst JpegImage = (function jpegImage() {\n    \"use strict\";\n    var dctZigZag = new Int32Array([\n        0,\n        1, 8,\n        16, 9, 2,\n        3, 10, 17, 24,\n        32, 25, 18, 11, 4,\n        5, 12, 19, 26, 33, 40,\n        48, 41, 34, 27, 20, 13, 6,\n        7, 14, 21, 28, 35, 42, 49, 56,\n        57, 50, 43, 36, 29, 22, 15,\n        23, 30, 37, 44, 51, 58,\n        59, 52, 45, 38, 31,\n        39, 46, 53, 60,\n        61, 54, 47,\n        55, 62,\n        63\n    ]);\n\n    var dctCos1 = 4017;   // cos(pi/16)\n    var dctSin1 = 799;   // sin(pi/16)\n    var dctCos3 = 3406;   // cos(3*pi/16)\n    var dctSin3 = 2276;   // sin(3*pi/16)\n    var dctCos6 = 1567;   // cos(6*pi/16)\n    var dctSin6 = 3784;   // sin(6*pi/16)\n    var dctSqrt2 = 5793;   // sqrt(2)\n    var dctSqrt1d2 = 2896;  // sqrt(2) / 2\n\n    function constructor() {\n    }\n\n    function buildHuffmanTable(codeLengths, values) {\n        var k = 0, code = [], i, j, length = 16;\n        while (length > 0 && !codeLengths[length - 1])\n            length--;\n        code.push({children: [], index: 0});\n        var p = code[0], q;\n        for (i = 0; i < length; i++) {\n            for (j = 0; j < codeLengths[i]; j++) {\n                p = code.pop();\n                p.children[p.index] = values[k];\n                while (p.index > 0) {\n                    p = code.pop();\n                }\n                p.index++;\n                code.push(p);\n                while (code.length <= i) {\n                    code.push(q = {children: [], index: 0});\n                    p.children[p.index] = q.children;\n                    p = q;\n                }\n                k++;\n            }\n            if (i + 1 < length) {\n                // p here points to last code\n                code.push(q = {children: [], index: 0});\n                p.children[p.index] = q.children;\n                p = q;\n            }\n        }\n        return code[0].children;\n    }\n\n    function getBlockBufferOffset(component, row, col) {\n        return 64 * ((component.blocksPerLine + 1) * row + col);\n    }\n\n    function decodeScan(data, offset,\n                        frame, components, resetInterval,\n                        spectralStart, spectralEnd,\n                        successivePrev, successive) {\n        var precision = frame.precision;\n        var samplesPerLine = frame.samplesPerLine;\n        var scanLines = frame.scanLines;\n        var mcusPerLine = frame.mcusPerLine;\n        var progressive = frame.progressive;\n        var maxH = frame.maxH, maxV = frame.maxV;\n\n        var startOffset = offset, bitsData = 0, bitsCount = 0;\n\n        function readBit() {\n            if (bitsCount > 0) {\n                bitsCount--;\n                return (bitsData >> bitsCount) & 1;\n            }\n            bitsData = data[offset++];\n            if (bitsData == 0xFF) {\n                var nextByte = data[offset++];\n                if (nextByte) {\n                    throw \"unexpected marker: \" + ((bitsData << 8) | nextByte).toString(16);\n                }\n                // unstuff 0\n            }\n            bitsCount = 7;\n            return bitsData >>> 7;\n        }\n\n        function decodeHuffman(tree) {\n            var node = tree;\n            var bit;\n            while ((bit = readBit()) !== null) {\n                node = node[bit];\n                if (typeof node === 'number')\n                    return node;\n                if (typeof node !== 'object')\n                    throw \"invalid huffman sequence\";\n            }\n            return null;\n        }\n\n        function receive(length) {\n            var n = 0;\n            while (length > 0) {\n                var bit = readBit();\n                if (bit === null)\n                    return;\n                n = (n << 1) | bit;\n                length--;\n            }\n            return n;\n        }\n\n        function receiveAndExtend(length) {\n            var n = receive(length);\n            if (n >= 1 << (length - 1))\n                return n;\n            return n + (-1 << length) + 1;\n        }\n\n        function decodeBaseline(component, offset) {\n            var t = decodeHuffman(component.huffmanTableDC);\n            var diff = t === 0 ? 0 : receiveAndExtend(t);\n            component.blockData[offset] = (component.pred += diff);\n            var k = 1;\n            while (k < 64) {\n                var rs = decodeHuffman(component.huffmanTableAC);\n                var s = rs & 15, r = rs >> 4;\n                if (s === 0) {\n                    if (r < 15)\n                        break;\n                    k += 16;\n                    continue;\n                }\n                k += r;\n                var z = dctZigZag[k];\n                component.blockData[offset + z] = receiveAndExtend(s);\n                k++;\n            }\n        }\n\n        function decodeDCFirst(component, offset) {\n            var t = decodeHuffman(component.huffmanTableDC);\n            var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n            component.blockData[offset] = (component.pred += diff);\n        }\n\n        function decodeDCSuccessive(component, offset) {\n            component.blockData[offset] |= readBit() << successive;\n        }\n\n        var eobrun = 0;\n        function decodeACFirst(component, offset) {\n            if (eobrun > 0) {\n                eobrun--;\n                return;\n            }\n            var k = spectralStart, e = spectralEnd;\n            while (k <= e) {\n                var rs = decodeHuffman(component.huffmanTableAC);\n                var s = rs & 15, r = rs >> 4;\n                if (s === 0) {\n                    if (r < 15) {\n                        eobrun = receive(r) + (1 << r) - 1;\n                        break;\n                    }\n                    k += 16;\n                    continue;\n                }\n                k += r;\n                var z = dctZigZag[k];\n                component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);\n                k++;\n            }\n        }\n\n        var successiveACState = 0, successiveACNextValue;\n        function decodeACSuccessive(component, offset) {\n            var k = spectralStart, e = spectralEnd, r = 0;\n            while (k <= e) {\n                var z = dctZigZag[k];\n                switch (successiveACState) {\n                    case 0: // initial state\n                        var rs = decodeHuffman(component.huffmanTableAC);\n                        var s = rs & 15;\n                        r = rs >> 4;\n                        if (s === 0) {\n                            if (r < 15) {\n                                eobrun = receive(r) + (1 << r);\n                                successiveACState = 4;\n                            } else {\n                                r = 16;\n                                successiveACState = 1;\n                            }\n                        } else {\n                            if (s !== 1)\n                                throw \"invalid ACn encoding\";\n                            successiveACNextValue = receiveAndExtend(s);\n                            successiveACState = r ? 2 : 3;\n                        }\n                        continue;\n                    case 1: // skipping r zero items\n                    case 2:\n                        if (component.blockData[offset + z]) {\n                            component.blockData[offset + z] += (readBit() << successive);\n                        } else {\n                            r--;\n                            if (r === 0)\n                                successiveACState = successiveACState == 2 ? 3 : 0;\n                        }\n                        break;\n                    case 3: // set value for a zero item\n                        if (component.blockData[offset + z]) {\n                            component.blockData[offset + z] += (readBit() << successive);\n                        } else {\n                            component.blockData[offset + z] = successiveACNextValue << successive;\n                            successiveACState = 0;\n                        }\n                        break;\n                    case 4: // eob\n                        if (component.blockData[offset + z]) {\n                            component.blockData[offset + z] += (readBit() << successive);\n                        }\n                        break;\n                }\n                k++;\n            }\n            if (successiveACState === 4) {\n                eobrun--;\n                if (eobrun === 0)\n                    successiveACState = 0;\n            }\n        }\n\n        function decodeMcu(component, decode, mcu, row, col) {\n            var mcuRow = (mcu / mcusPerLine) | 0;\n            var mcuCol = mcu % mcusPerLine;\n            var blockRow = mcuRow * component.v + row;\n            var blockCol = mcuCol * component.h + col;\n            var offset = getBlockBufferOffset(component, blockRow, blockCol);\n            decode(component, offset);\n        }\n\n        function decodeBlock(component, decode, mcu) {\n            var blockRow = (mcu / component.blocksPerLine) | 0;\n            var blockCol = mcu % component.blocksPerLine;\n            var offset = getBlockBufferOffset(component, blockRow, blockCol);\n            decode(component, offset);\n        }\n\n        var componentsLength = components.length;\n        var component, i, j, k, n;\n        var decodeFn;\n        if (progressive) {\n            if (spectralStart === 0)\n                decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n            else\n                decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n        } else {\n            decodeFn = decodeBaseline;\n        }\n\n        var mcu = 0, marker;\n        var mcuExpected;\n        if (componentsLength == 1) {\n            mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n        } else {\n            mcuExpected = mcusPerLine * frame.mcusPerColumn;\n        }\n        if (!resetInterval) {\n            resetInterval = mcuExpected;\n        }\n\n        var h, v;\n        while (mcu < mcuExpected) {\n            // reset interval stuff\n            for (i = 0; i < componentsLength; i++) {\n                components[i].pred = 0;\n            }\n            eobrun = 0;\n\n            if (componentsLength == 1) {\n                component = components[0];\n                for (n = 0; n < resetInterval; n++) {\n                    decodeBlock(component, decodeFn, mcu);\n                    mcu++;\n                }\n            } else {\n                for (n = 0; n < resetInterval; n++) {\n                    for (i = 0; i < componentsLength; i++) {\n                        component = components[i];\n                        h = component.h;\n                        v = component.v;\n                        for (j = 0; j < v; j++) {\n                            for (k = 0; k < h; k++) {\n                                decodeMcu(component, decodeFn, mcu, j, k);\n                            }\n                        }\n                    }\n                    mcu++;\n                }\n            }\n\n            // find marker\n            bitsCount = 0;\n            marker = (data[offset] << 8) | data[offset + 1];\n            if (marker <= 0xFF00) {\n                throw \"marker was not found\";\n            }\n\n            if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n                offset += 2;\n            } else {\n                break;\n            }\n        }\n\n        return offset - startOffset;\n    }\n\n    // A port of poppler's IDCT method which in turn is taken from:\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n    //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n    //   988-991.\n    function quantizeAndInverse(component, blockBufferOffset, p) {\n        var qt = component.quantizationTable;\n        var v0, v1, v2, v3, v4, v5, v6, v7, t;\n        var i;\n\n        // dequant\n        for (i = 0; i < 64; i++) {\n            p[i] = component.blockData[blockBufferOffset + i] * qt[i];\n        }\n\n        // inverse DCT on rows\n        for (i = 0; i < 8; ++i) {\n            var row = 8 * i;\n\n            // check for all-zero AC coefficients\n            if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0 &&\n                p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0 &&\n                p[7 + row] === 0) {\n                t = (dctSqrt2 * p[0 + row] + 512) >> 10;\n                p[0 + row] = t;\n                p[1 + row] = t;\n                p[2 + row] = t;\n                p[3 + row] = t;\n                p[4 + row] = t;\n                p[5 + row] = t;\n                p[6 + row] = t;\n                p[7 + row] = t;\n                continue;\n            }\n\n            // stage 4\n            v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;\n            v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;\n            v2 = p[2 + row];\n            v3 = p[6 + row];\n            v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;\n            v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;\n            v5 = p[3 + row] << 4;\n            v6 = p[5 + row] << 4;\n\n            // stage 3\n            t = (v0 - v1 + 1) >> 1;\n            v0 = (v0 + v1 + 1) >> 1;\n            v1 = t;\n            t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;\n            v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;\n            v3 = t;\n            t = (v4 - v6 + 1) >> 1;\n            v4 = (v4 + v6 + 1) >> 1;\n            v6 = t;\n            t = (v7 + v5 + 1) >> 1;\n            v5 = (v7 - v5 + 1) >> 1;\n            v7 = t;\n\n            // stage 2\n            t = (v0 - v3 + 1) >> 1;\n            v0 = (v0 + v3 + 1) >> 1;\n            v3 = t;\n            t = (v1 - v2 + 1) >> 1;\n            v1 = (v1 + v2 + 1) >> 1;\n            v2 = t;\n            t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n            v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n            v7 = t;\n            t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n            v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n            v6 = t;\n\n            // stage 1\n            p[0 + row] = v0 + v7;\n            p[7 + row] = v0 - v7;\n            p[1 + row] = v1 + v6;\n            p[6 + row] = v1 - v6;\n            p[2 + row] = v2 + v5;\n            p[5 + row] = v2 - v5;\n            p[3 + row] = v3 + v4;\n            p[4 + row] = v3 - v4;\n        }\n\n        // inverse DCT on columns\n        for (i = 0; i < 8; ++i) {\n            var col = i;\n\n            // check for all-zero AC coefficients\n            if (p[1 * 8 + col] === 0 && p[2 * 8 + col] === 0 && p[3 * 8 + col] === 0 &&\n                p[4 * 8 + col] === 0 && p[5 * 8 + col] === 0 && p[6 * 8 + col] === 0 &&\n                p[7 * 8 + col] === 0) {\n                t = (dctSqrt2 * p[i + 0] + 8192) >> 14;\n                p[0 * 8 + col] = t;\n                p[1 * 8 + col] = t;\n                p[2 * 8 + col] = t;\n                p[3 * 8 + col] = t;\n                p[4 * 8 + col] = t;\n                p[5 * 8 + col] = t;\n                p[6 * 8 + col] = t;\n                p[7 * 8 + col] = t;\n                continue;\n            }\n\n            // stage 4\n            v0 = (dctSqrt2 * p[0 * 8 + col] + 2048) >> 12;\n            v1 = (dctSqrt2 * p[4 * 8 + col] + 2048) >> 12;\n            v2 = p[2 * 8 + col];\n            v3 = p[6 * 8 + col];\n            v4 = (dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048) >> 12;\n            v7 = (dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048) >> 12;\n            v5 = p[3 * 8 + col];\n            v6 = p[5 * 8 + col];\n\n            // stage 3\n            t = (v0 - v1 + 1) >> 1;\n            v0 = (v0 + v1 + 1) >> 1;\n            v1 = t;\n            t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;\n            v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;\n            v3 = t;\n            t = (v4 - v6 + 1) >> 1;\n            v4 = (v4 + v6 + 1) >> 1;\n            v6 = t;\n            t = (v7 + v5 + 1) >> 1;\n            v5 = (v7 - v5 + 1) >> 1;\n            v7 = t;\n\n            // stage 2\n            t = (v0 - v3 + 1) >> 1;\n            v0 = (v0 + v3 + 1) >> 1;\n            v3 = t;\n            t = (v1 - v2 + 1) >> 1;\n            v1 = (v1 + v2 + 1) >> 1;\n            v2 = t;\n            t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n            v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n            v7 = t;\n            t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n            v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n            v6 = t;\n\n            // stage 1\n            p[0 * 8 + col] = v0 + v7;\n            p[7 * 8 + col] = v0 - v7;\n            p[1 * 8 + col] = v1 + v6;\n            p[6 * 8 + col] = v1 - v6;\n            p[2 * 8 + col] = v2 + v5;\n            p[5 * 8 + col] = v2 - v5;\n            p[3 * 8 + col] = v3 + v4;\n            p[4 * 8 + col] = v3 - v4;\n        }\n\n        // convert to 8-bit integers\n        for (i = 0; i < 64; ++i) {\n            var index = blockBufferOffset + i;\n            var q = p[i];\n            q = (q <= -2056 / component.bitConversion) ? 0 :\n                (q >= 2024 / component.bitConversion) ? 255 / component.bitConversion :\n                (q + 2056 / component.bitConversion) >> 4;\n            component.blockData[index] = q;\n        }\n    }\n\n    function buildComponentData(frame, component) {\n        var lines = [];\n        var blocksPerLine = component.blocksPerLine;\n        var blocksPerColumn = component.blocksPerColumn;\n        var samplesPerLine = blocksPerLine << 3;\n        var computationBuffer = new Int32Array(64);\n\n        var i, j, ll = 0;\n        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n            for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n                var offset = getBlockBufferOffset(component, blockRow, blockCol);\n                quantizeAndInverse(component, offset, computationBuffer);\n            }\n        }\n        return component.blockData;\n    }\n\n    function clampToUint8(a) {\n        return a <= 0 ? 0 : a >= 255 ? 255 : a | 0;\n    }\n\n    constructor.prototype = {\n        load: function load(path) {\n            var handleData = (function (data) {\n                this.parse(data);\n                if (this.onload)\n                    this.onload();\n            }).bind(this);\n\n            if (path.indexOf(\"data:\") > -1) {\n                var offset = path.indexOf(\"base64,\") + 7;\n                var data = atob(path.substring(offset));\n                var arr = new Uint8Array(data.length);\n                for (var i = data.length - 1; i >= 0; i--) {\n                    arr[i] = data.charCodeAt(i);\n                }\n                handleData(data);\n            } else {\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"GET\", path, true);\n                xhr.responseType = \"arraybuffer\";\n                xhr.onload = (function () {\n                    // TODO catch parse error\n                    var data = new Uint8Array(xhr.response);\n                    handleData(data);\n                }).bind(this);\n                xhr.send(null);\n            }\n        },\n        parse: function parse(data) {\n\n            function readUint16() {\n                var value = (data[offset] << 8) | data[offset + 1];\n                offset += 2;\n                return value;\n            }\n\n            function readDataBlock() {\n                var length = readUint16();\n                var array = data.subarray(offset, offset + length - 2);\n                offset += array.length;\n                return array;\n            }\n\n            function prepareComponents(frame) {\n                var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);\n                var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);\n                for (var i = 0; i < frame.components.length; i++) {\n                    component = frame.components[i];\n                    var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);\n                    var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);\n                    var blocksPerLineForMcu = mcusPerLine * component.h;\n                    var blocksPerColumnForMcu = mcusPerColumn * component.v;\n\n                    var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);\n                    component.blockData = new Int16Array(blocksBufferSize);\n                    component.blocksPerLine = blocksPerLine;\n                    component.blocksPerColumn = blocksPerColumn;\n                }\n                frame.mcusPerLine = mcusPerLine;\n                frame.mcusPerColumn = mcusPerColumn;\n            }\n\n            var offset = 0, length = data.length;\n            var jfif = null;\n            var adobe = null;\n            var pixels = null;\n            var frame, resetInterval;\n            var quantizationTables = [];\n            var huffmanTablesAC = [], huffmanTablesDC = [];\n            var fileMarker = readUint16();\n            if (fileMarker != 0xFFD8) { // SOI (Start of Image)\n                throw \"SOI not found\";\n            }\n\n            fileMarker = readUint16();\n            while (fileMarker != 0xFFD9) { // EOI (End of image)\n                var i, j, l;\n                switch (fileMarker) {\n                    case 0xFFE0: // APP0 (Application Specific)\n                    case 0xFFE1: // APP1\n                    case 0xFFE2: // APP2\n                    case 0xFFE3: // APP3\n                    case 0xFFE4: // APP4\n                    case 0xFFE5: // APP5\n                    case 0xFFE6: // APP6\n                    case 0xFFE7: // APP7\n                    case 0xFFE8: // APP8\n                    case 0xFFE9: // APP9\n                    case 0xFFEA: // APP10\n                    case 0xFFEB: // APP11\n                    case 0xFFEC: // APP12\n                    case 0xFFED: // APP13\n                    case 0xFFEE: // APP14\n                    case 0xFFEF: // APP15\n                    case 0xFFFE: // COM (Comment)\n                        var appData = readDataBlock();\n\n                        if (fileMarker === 0xFFE0) {\n                            if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&\n                                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n                                jfif = {\n                                    version: {major: appData[5], minor: appData[6]},\n                                    densityUnits: appData[7],\n                                    xDensity: (appData[8] << 8) | appData[9],\n                                    yDensity: (appData[10] << 8) | appData[11],\n                                    thumbWidth: appData[12],\n                                    thumbHeight: appData[13],\n                                    thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                                };\n                            }\n                        }\n                        // TODO APP1 - Exif\n                        if (fileMarker === 0xFFEE) {\n                            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&\n                                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n                                adobe = {\n                                    version: appData[6],\n                                    flags0: (appData[7] << 8) | appData[8],\n                                    flags1: (appData[9] << 8) | appData[10],\n                                    transformCode: appData[11]\n                                };\n                            }\n                        }\n                        break;\n\n                    case 0xFFDB: // DQT (Define Quantization Tables)\n                        var quantizationTablesLength = readUint16();\n                        var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n                        while (offset < quantizationTablesEnd) {\n                            var quantizationTableSpec = data[offset++];\n                            var tableData = new Int32Array(64);\n                            if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n                                for (j = 0; j < 64; j++) {\n                                    var z = dctZigZag[j];\n                                    tableData[z] = data[offset++];\n                                }\n                            } else if ((quantizationTableSpec >> 4) === 1) { //16 bit\n                                for (j = 0; j < 64; j++) {\n                                    var zz = dctZigZag[j];\n                                    tableData[zz] = readUint16();\n                                }\n                            } else\n                                throw \"DQT: invalid table spec\";\n                            quantizationTables[quantizationTableSpec & 15] = tableData;\n                        }\n                        break;\n\n                    case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n                    case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n                    case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)\n                        if (frame) {\n                            throw \"Only single frame JPEGs supported\";\n                        }\n                        readUint16(); // skip data length\n                        frame = {};\n                        frame.extended = (fileMarker === 0xFFC1);\n                        frame.progressive = (fileMarker === 0xFFC2);\n                        frame.precision = data[offset++];\n                        frame.scanLines = readUint16();\n                        frame.samplesPerLine = readUint16();\n                        frame.components = [];\n                        frame.componentIds = {};\n                        var componentsCount = data[offset++], componentId;\n                        var maxH = 0, maxV = 0;\n                        for (i = 0; i < componentsCount; i++) {\n                            componentId = data[offset];\n                            var h = data[offset + 1] >> 4;\n                            var v = data[offset + 1] & 15;\n                            if (maxH < h)\n                                maxH = h;\n                            if (maxV < v)\n                                maxV = v;\n                            var qId = data[offset + 2];\n                            l = frame.components.push({\n                                h: h,\n                                v: v,\n                                quantizationTable: quantizationTables[qId],\n                                quantizationTableId: qId,\n                                bitConversion: 255 / ((1 << frame.precision) - 1)\n                            });\n                            frame.componentIds[componentId] = l - 1;\n                            offset += 3;\n                        }\n                        frame.maxH = maxH;\n                        frame.maxV = maxV;\n                        prepareComponents(frame);\n                        break;\n\n                    case 0xFFC4: // DHT (Define Huffman Tables)\n                        var huffmanLength = readUint16();\n                        for (i = 2; i < huffmanLength; ) {\n                            var huffmanTableSpec = data[offset++];\n                            var codeLengths = new Uint8Array(16);\n                            var codeLengthSum = 0;\n                            for (j = 0; j < 16; j++, offset++)\n                                codeLengthSum += (codeLengths[j] = data[offset]);\n                            var huffmanValues = new Uint8Array(codeLengthSum);\n                            for (j = 0; j < codeLengthSum; j++, offset++)\n                                huffmanValues[j] = data[offset];\n                            i += 17 + codeLengthSum;\n\n                            ((huffmanTableSpec >> 4) === 0 ?\n                                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =\n                                buildHuffmanTable(codeLengths, huffmanValues);\n                        }\n                        break;\n\n                    case 0xFFDD: // DRI (Define Restart Interval)\n                        readUint16(); // skip data length\n                        resetInterval = readUint16();\n                        break;\n\n                    case 0xFFDA: // SOS (Start of Scan)\n                        var scanLength = readUint16();\n                        var selectorsCount = data[offset++];\n                        var components = [], component;\n                        for (i = 0; i < selectorsCount; i++) {\n                            var componentIndex = frame.componentIds[data[offset++]];\n                            component = frame.components[componentIndex];\n                            var tableSpec = data[offset++];\n                            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n                            component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n                            components.push(component);\n                        }\n                        var spectralStart = data[offset++];\n                        var spectralEnd = data[offset++];\n                        var successiveApproximation = data[offset++];\n                        var processed = decodeScan(data, offset,\n                            frame, components, resetInterval,\n                            spectralStart, spectralEnd,\n                            successiveApproximation >> 4, successiveApproximation & 15);\n                        offset += processed;\n                        break;\n\n                    case 0xFFFF: // Fill bytes\n                        if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\n                            offset--;\n                        }\n                        break;\n\n                    default:\n                        if (data[offset - 3] == 0xFF &&\n                            data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n                            // could be incorrect encoding -- last 0xFF byte of the previous\n                            // block was eaten by the encoder\n                            offset -= 3;\n                            break;\n                        }\n                        throw \"unknown JPEG marker \" + fileMarker.toString(16);\n                }\n                fileMarker = readUint16();\n            }\n\n            this.width = frame.samplesPerLine;\n            this.height = frame.scanLines;\n            this.jfif = jfif;\n            this.adobe = adobe;\n            this.components = [];\n            switch (frame.components.length)\n            {\n                case 1:\n                    this.colorspace = ColorSpace.Grayscale;\n                    break;\n                case 3:\n                    if (this.adobe)\n                        this.colorspace = ColorSpace.AdobeRGB;\n                    else\n                        this.colorspace = ColorSpace.RGB;\n                    break;\n                case 4:\n                    this.colorspace = ColorSpace.CYMK;\n                    break;\n                default:\n                    this.colorspace = ColorSpace.Unknown;\n            }\n            for (var i = 0; i < frame.components.length; i++) {\n                var component = frame.components[i];\n                if (!component.quantizationTable && component.quantizationTableId !== null)\n                    component.quantizationTable = quantizationTables[component.quantizationTableId];\n                this.components.push({\n                    output: buildComponentData(frame, component),\n                    scaleX: component.h / frame.maxH,\n                    scaleY: component.v / frame.maxV,\n                    blocksPerLine: component.blocksPerLine,\n                    blocksPerColumn: component.blocksPerColumn,\n                    bitConversion: component.bitConversion\n                });\n            }\n        },\n        getData16: function getData16(width, height) {\n            if (this.components.length !== 1)\n                throw 'Unsupported color mode';\n            var scaleX = this.width / width, scaleY = this.height / height;\n\n            var component, componentScaleX, componentScaleY;\n            var x, y, i;\n            var offset = 0;\n            var numComponents = this.components.length;\n            var dataLength = width * height * numComponents;\n            var data = new Uint16Array(dataLength);\n            var componentLine;\n\n            // lineData is reused for all components. Assume first component is\n            // the biggest\n            var lineData = new Uint16Array((this.components[0].blocksPerLine << 3) *\n                this.components[0].blocksPerColumn * 8);\n\n            // First construct image data ...\n            for (i = 0; i < numComponents; i++) {\n                component = this.components[i];\n                var blocksPerLine = component.blocksPerLine;\n                var blocksPerColumn = component.blocksPerColumn;\n                var samplesPerLine = blocksPerLine << 3;\n\n                var j, k, ll = 0;\n                var lineOffset = 0;\n                for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n                    var scanLine = blockRow << 3;\n                    for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n                        var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);\n                        var offset = 0, sample = blockCol << 3;\n                        for (j = 0; j < 8; j++) {\n                            var lineOffset = (scanLine + j) * samplesPerLine;\n                            for (k = 0; k < 8; k++) {\n                                lineData[lineOffset + sample + k] =\n                                    component.output[bufferOffset + offset++];\n                            }\n                        }\n                    }\n                }\n\n                componentScaleX = component.scaleX * scaleX;\n                componentScaleY = component.scaleY * scaleY;\n                offset = i;\n\n                var cx, cy;\n                var index;\n                for (y = 0; y < height; y++) {\n                    for (x = 0; x < width; x++) {\n                        cy = 0 | (y * componentScaleY);\n                        cx = 0 | (x * componentScaleX);\n                        index = cy * samplesPerLine + cx;\n                        data[offset] = lineData[index];\n                        offset += numComponents;\n                    }\n                }\n            }\n            return data;\n        },\n        getData: function getData(width, height) {\n            var scaleX = this.width / width, scaleY = this.height / height;\n\n            var component, componentScaleX, componentScaleY;\n            var x, y, i;\n            var offset = 0;\n            var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n            var colorTransform;\n            var numComponents = this.components.length;\n            var dataLength = width * height * numComponents;\n            var data = new Uint8Array(dataLength);\n            var componentLine;\n\n            // lineData is reused for all components. Assume first component is\n            // the biggest\n            var lineData = new Uint8Array((this.components[0].blocksPerLine << 3) *\n                this.components[0].blocksPerColumn * 8);\n\n            // First construct image data ...\n            for (i = 0; i < numComponents; i++) {\n                component = this.components[i];\n                var blocksPerLine = component.blocksPerLine;\n                var blocksPerColumn = component.blocksPerColumn;\n                var samplesPerLine = blocksPerLine << 3;\n\n                var j, k, ll = 0;\n                var lineOffset = 0;\n                for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n                    var scanLine = blockRow << 3;\n                    for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n                        var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);\n                        var offset = 0, sample = blockCol << 3;\n                        for (j = 0; j < 8; j++) {\n                            var lineOffset = (scanLine + j) * samplesPerLine;\n                            for (k = 0; k < 8; k++) {\n                                lineData[lineOffset + sample + k] =\n                                    component.output[bufferOffset + offset++] * component.bitConversion;\n                            }\n                        }\n                    }\n                }\n\n                componentScaleX = component.scaleX * scaleX;\n                componentScaleY = component.scaleY * scaleY;\n                offset = i;\n\n                var cx, cy;\n                var index;\n                for (y = 0; y < height; y++) {\n                    for (x = 0; x < width; x++) {\n                        cy = 0 | (y * componentScaleY);\n                        cx = 0 | (x * componentScaleX);\n                        index = cy * samplesPerLine + cx;\n                        data[offset] = lineData[index];\n                        offset += numComponents;\n                    }\n                }\n            }\n\n            // ... then transform colors, if necessary\n            switch (numComponents) {\n                case 1:\n                case 2:\n                    break;\n                // no color conversion for one or two compoenents\n\n                case 3:\n                    // The default transform for three components is true\n                    colorTransform = true;\n                    // The adobe transform marker overrides any previous setting\n                    if (this.adobe && this.adobe.transformCode)\n                        colorTransform = true;\n                    else if (typeof this.colorTransform !== 'undefined')\n                        colorTransform = !!this.colorTransform;\n\n                    if (colorTransform) {\n                        for (i = 0; i < dataLength; i += numComponents) {\n                            Y = data[i    ];\n                            Cb = data[i + 1];\n                            Cr = data[i + 2];\n\n                            R = clampToUint8(Y - 179.456 + 1.402 * Cr);\n                            G = clampToUint8(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);\n                            B = clampToUint8(Y - 226.816 + 1.772 * Cb);\n\n                            data[i    ] = R;\n                            data[i + 1] = G;\n                            data[i + 2] = B;\n                        }\n                    }\n                    break;\n                case 4:\n                    if (!this.adobe)\n                        throw 'Unsupported color mode (4 components)';\n                    // The default transform for four components is false\n                    colorTransform = false;\n                    // The adobe transform marker overrides any previous setting\n                    if (this.adobe && this.adobe.transformCode)\n                        colorTransform = true;\n                    else if (typeof this.colorTransform !== 'undefined')\n                        colorTransform = !!this.colorTransform;\n\n                    if (colorTransform) {\n                        for (i = 0; i < dataLength; i += numComponents) {\n                            Y = data[i];\n                            Cb = data[i + 1];\n                            Cr = data[i + 2];\n\n                            C = clampToUint8(434.456 - Y - 1.402 * Cr);\n                            M = clampToUint8(119.541 - Y + 0.344 * Cb + 0.714 * Cr);\n                            Y = clampToUint8(481.816 - Y - 1.772 * Cb);\n\n                            data[i    ] = C;\n                            data[i + 1] = M;\n                            data[i + 2] = Y;\n                            // K is unchanged\n                        }\n                    }\n                    break;\n                default:\n                    throw 'Unsupported color mode';\n            }\n            return data;\n        }\n    };\n\n    return constructor;\n})();\n\nexport {\n\tJpegImage,\n\tColorSpace\n};\n\n\n"],"names":["ColorSpace","Unkown","Grayscale","AdobeRGB","RGB","CYMK","JpegImage","dctZigZag","Int32Array","dctCos1","dctSin1","dctCos3","dctSin3","dctCos6","dctSin6","dctSqrt2","dctSqrt1d2","constructor","buildHuffmanTable","codeLengths","values","i","j","k","code","length","push","children","index","q","p","pop","getBlockBufferOffset","component","row","col","blocksPerLine","decodeScan","data","offset","frame","components","resetInterval","spectralStart","spectralEnd","successivePrev","successive","mcusPerLine","progressive","startOffset","bitsData","bitsCount","readBit","nextByte","toString","decodeHuffman","tree","bit","node","receive","n","receiveAndExtend","eobrun","successiveACNextValue","successiveACState","decodeMcu","decode","mcu","mcuCol","v","h","decodeBlock","decodeFn","componentsLength","t","huffmanTableDC","diff","blockData","pred","e","rs","huffmanTableAC","s","r","z","marker","mcuExpected","blocksPerColumn","mcusPerColumn","quantizeAndInverse","blockBufferOffset","v0","v1","v2","v3","v4","v5","v6","v7","qt","quantizationTable","bitConversion","buildComponentData","computationBuffer","blockRow","blockCol","clampToUint8","a","prototype","load","path","handleData","this","parse","onload","bind","indexOf","atob","substring","arr","Uint8Array","charCodeAt","xhr","XMLHttpRequest","open","responseType","response","send","readUint16","value","readDataBlock","array","subarray","prepareComponents","Math","ceil","samplesPerLine","maxH","scanLines","maxV","blocksPerLineForMcu","blocksBufferSize","Int16Array","jfif","adobe","quantizationTables","huffmanTablesAC","huffmanTablesDC","fileMarker","l","appData","version","major","minor","densityUnits","xDensity","yDensity","thumbWidth","thumbHeight","thumbData","flags0","flags1","transformCode","quantizationTablesEnd","quantizationTableSpec","tableData","extended","precision","componentIds","componentId","componentsCount","qId","quantizationTableId","huffmanLength","huffmanTableSpec","codeLengthSum","huffmanValues","selectorsCount","componentIndex","tableSpec","successiveApproximation","processed","width","height","colorspace","Unknown","output","scaleX","scaleY","getData16","componentScaleX","componentScaleY","x","y","numComponents","Uint16Array","lineData","lineOffset","scanLine","bufferOffset","sample","getData","Y","Cb","Cr","C","M","R","G","B","colorTransform","dataLength"],"sourceRoot":""}