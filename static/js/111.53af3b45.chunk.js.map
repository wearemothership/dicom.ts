{"version":3,"file":"static/js/111.53af3b45.chunk.js","mappings":"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","sources":["../../src/decoder/codecs/charlsjs.js","../../node_modules/node-fetch/browser.js"],"sourcesContent":["// MIT License\n\n// Copyright (c) 2020 Chris Hafey\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n/* istanbul ignore file */\n\n/* eslint-disable */\nimport raw from \"raw.macro\";\n\nvar CharLS = (function (opts) {\n\tvar Module = typeof opts !== \"undefined\" ? opts : {};\n\tvar moduleOverrides = {};\n\tvar key;\n\tfor (key in Module) {\n\t\tif (Module.hasOwnProperty(key)) {\n\t\t\tmoduleOverrides[key] = Module[key]\n\t\t}\n\t}\n\tvar arguments_ = [];\n\tvar thisProgram = \"./this.program\";\n\tvar quit_ = function (status, toThrow) {\n\t\tthrow toThrow\n\t};\n\tvar ENVIRONMENT_IS_WEB = false;\n\tvar ENVIRONMENT_IS_WORKER = false;\n\tvar ENVIRONMENT_IS_NODE = false;\n\tvar ENVIRONMENT_IS_SHELL = false;\n\tENVIRONMENT_IS_WEB = typeof window === \"object\";\n\tENVIRONMENT_IS_WORKER = typeof importScripts === \"function\";\n\tENVIRONMENT_IS_NODE = typeof process === \"object\" && typeof process.versions === \"object\" && typeof process.versions.node === \"string\";\n\tENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\tvar scriptDirectory = \"\";\n\n\tif (ENVIRONMENT_IS_NODE && globalThis && !globalThis.fetch) {\n\t\tglobalThis.fetch = require(\"node-fetch\");\n\t}\n\n\tfunction locateFile(path) {\n\t\tif (Module[\"locateFile\"]) {\n\t\t\treturn Module[\"locateFile\"](path, scriptDirectory)\n\t\t}\n\t\treturn scriptDirectory + path\n\t}\n\tvar read_, readAsync, readBinary, setWindowTitle;\n\tvar nodeFS;\n\tvar nodePath;\n\tif (ENVIRONMENT_IS_NODE) {\n\t\tif (ENVIRONMENT_IS_WORKER) {\n\t\t\tscriptDirectory = require(\"path\").dirname(scriptDirectory) + \"/\"\n\t\t} else {\n\t\t\tscriptDirectory = __dirname + \"/\"\n\t\t}\n\t\tread_ = function shell_read(filename, binary) {\n\t\t\tif (!nodeFS) nodeFS = require(\"fs\");\n\t\t\tif (!nodePath) nodePath = require(\"path\");\n\t\t\tfilename = nodePath[\"normalize\"](filename);\n\t\t\treturn nodeFS[\"readFileSync\"](filename, binary ? null : \"utf8\")\n\t\t};\n\t\treadBinary = function readBinary(filename) {\n\t\t\tvar ret = read_(filename, true);\n\t\t\tif (!ret.buffer) {\n\t\t\t\tret = new Uint8Array(ret)\n\t\t\t}\n\t\t\tassert(ret.buffer);\n\t\t\treturn ret\n\t\t};\n\t\tif (process[\"argv\"].length > 1) {\n\t\t\tthisProgram = process[\"argv\"][1].replace(/\\\\/g, \"/\")\n\t\t}\n\t\targuments_ = process[\"argv\"].slice(2);\n\t\tif (typeof module !== \"undefined\") {\n\t\t\tmodule[\"exports\"] = Module\n\t\t}\n\t\tprocess[\"on\"](\"uncaughtException\", function (ex) {\n\t\t\tif (!(ex instanceof ExitStatus)) {\n\t\t\t\tthrow ex\n\t\t\t}\n\t\t});\n\t\tprocess[\"on\"](\"unhandledRejection\", abort);\n\t\tquit_ = function (status) {\n\t\t\tprocess[\"exit\"](status)\n\t\t};\n\t\tModule[\"inspect\"] = function () {\n\t\t\treturn \"[Emscripten Module object]\"\n\t\t}\n\t} else if (ENVIRONMENT_IS_SHELL) {\n\t\tif (typeof read != \"undefined\") {\n\t\t\tread_ = function shell_read(f) {\n\t\t\t\treturn read(f)\n\t\t\t}\n\t\t}\n\t\treadBinary = function readBinary(f) {\n\t\t\tvar data;\n\t\t\tif (typeof readbuffer === \"function\") {\n\t\t\t\treturn new Uint8Array(readbuffer(f))\n\t\t\t}\n\t\t\tdata = read(f, \"binary\");\n\t\t\tassert(typeof data === \"object\");\n\t\t\treturn data\n\t\t};\n\t\tif (typeof scriptArgs != \"undefined\") {\n\t\t\targuments_ = scriptArgs\n\t\t} else if (typeof arguments != \"undefined\") {\n\t\t\targuments_ = arguments\n\t\t}\n\t\tif (typeof quit === \"function\") {\n\t\t\tquit_ = function (status) {\n\t\t\t\tquit(status)\n\t\t\t}\n\t\t}\n\t\tif (typeof print !== \"undefined\") {\n\t\t\tif (typeof console === \"undefined\") console = {};\n\t\t\tconsole.log = print;\n\t\t\tconsole.warn = console.error = typeof printErr !== \"undefined\" ? printErr : print\n\t\t}\n\t} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n\t\tif (ENVIRONMENT_IS_WORKER) {\n\t\t\tscriptDirectory = self.location.href\n\t\t} else if (document.currentScript) {\n\t\t\tscriptDirectory = document.currentScript.src\n\t\t}\n\t\tif (scriptDirectory.indexOf(\"blob:\") !== 0) {\n\t\t\tscriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf(\"/\") + 1)\n\t\t} else {\n\t\t\tscriptDirectory = \"\"\n\t\t} {\n\t\t\tread_ = function shell_read(url) {\n\t\t\t\tvar xhr = new XMLHttpRequest;\n\t\t\t\txhr.open(\"GET\", url, false);\n\t\t\t\txhr.send(null);\n\t\t\t\treturn xhr.responseText\n\t\t\t};\n\t\t\tif (ENVIRONMENT_IS_WORKER) {\n\t\t\t\treadBinary = function readBinary(url) {\n\t\t\t\t\tvar xhr = new XMLHttpRequest;\n\t\t\t\t\txhr.open(\"GET\", url, false);\n\t\t\t\t\txhr.responseType = \"arraybuffer\";\n\t\t\t\t\txhr.send(null);\n\t\t\t\t\treturn new Uint8Array(xhr.response)\n\t\t\t\t}\n\t\t\t}\n\t\t\treadAsync = function readAsync(url, onload, onerror) {\n\t\t\t\tvar xhr = new XMLHttpRequest;\n\t\t\t\txhr.open(\"GET\", url, true);\n\t\t\t\txhr.responseType = \"arraybuffer\";\n\t\t\t\txhr.onload = function xhr_onload() {\n\t\t\t\t\tif (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n\t\t\t\t\t\tonload(xhr.response);\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tonerror()\n\t\t\t\t};\n\t\t\t\txhr.onerror = onerror;\n\t\t\t\txhr.send(null)\n\t\t\t}\n\t\t}\n\t\tsetWindowTitle = function (title) {\n\t\t\tdocument.title = title\n\t\t}\n\t} else {}\n\tvar out = Module[\"print\"] || console.log.bind(console);\n\tvar err = Module[\"printErr\"] || console.warn.bind(console);\n\tfor (key in moduleOverrides) {\n\t\tif (moduleOverrides.hasOwnProperty(key)) {\n\t\t\tModule[key] = moduleOverrides[key]\n\t\t}\n\t}\n\tmoduleOverrides = null;\n\tif (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n\tif (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n\tif (Module[\"quit\"]) quit_ = Module[\"quit\"];\n\tvar STACK_ALIGN = 16;\n\n\tfunction dynamicAlloc(size) {\n\t\tvar ret = HEAP32[DYNAMICTOP_PTR >> 2];\n\t\tvar end = ret + size + 15 & -16;\n\t\tHEAP32[DYNAMICTOP_PTR >> 2] = end;\n\t\treturn ret\n\t}\n\n\tfunction getNativeTypeSize(type) {\n\t\tswitch (type) {\n\t\t\tcase \"i1\":\n\t\t\tcase \"i8\":\n\t\t\t\treturn 1;\n\t\t\tcase \"i16\":\n\t\t\t\treturn 2;\n\t\t\tcase \"i32\":\n\t\t\t\treturn 4;\n\t\t\tcase \"i64\":\n\t\t\t\treturn 8;\n\t\t\tcase \"float\":\n\t\t\t\treturn 4;\n\t\t\tcase \"double\":\n\t\t\t\treturn 8;\n\t\t\tdefault: {\n\t\t\t\tif (type[type.length - 1] === \"*\") {\n\t\t\t\t\treturn 4\n\t\t\t\t} else if (type[0] === \"i\") {\n\t\t\t\t\tvar bits = Number(type.substr(1));\n\t\t\t\t\tassert(bits % 8 === 0, \"getNativeTypeSize invalid bits \" + bits + \", type \" + type);\n\t\t\t\t\treturn bits / 8\n\t\t\t\t} else {\n\t\t\t\t\treturn 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction warnOnce(text) {\n\t\tif (!warnOnce.shown) warnOnce.shown = {};\n\t\tif (!warnOnce.shown[text]) {\n\t\t\twarnOnce.shown[text] = 1;\n\t\t\terr(text)\n\t\t}\n\t}\n\n\tfunction convertJsFunctionToWasm(func, sig) {\n\t\tif (typeof WebAssembly.Function === \"function\") {\n\t\t\tvar typeNames = {\n\t\t\t\t\"i\": \"i32\",\n\t\t\t\t\"j\": \"i64\",\n\t\t\t\t\"f\": \"f32\",\n\t\t\t\t\"d\": \"f64\"\n\t\t\t};\n\t\t\tvar type = {\n\t\t\t\tparameters: [],\n\t\t\t\tresults: sig[0] == \"v\" ? [] : [typeNames[sig[0]]]\n\t\t\t};\n\t\t\tfor (var i = 1; i < sig.length; ++i) {\n\t\t\t\ttype.parameters.push(typeNames[sig[i]])\n\t\t\t}\n\t\t\treturn new WebAssembly.Function(type, func)\n\t\t}\n\t\tvar typeSection = [1, 0, 1, 96];\n\t\tvar sigRet = sig.slice(0, 1);\n\t\tvar sigParam = sig.slice(1);\n\t\tvar typeCodes = {\n\t\t\t\"i\": 127,\n\t\t\t\"j\": 126,\n\t\t\t\"f\": 125,\n\t\t\t\"d\": 124\n\t\t};\n\t\ttypeSection.push(sigParam.length);\n\t\tfor (var i = 0; i < sigParam.length; ++i) {\n\t\t\ttypeSection.push(typeCodes[sigParam[i]])\n\t\t}\n\t\tif (sigRet == \"v\") {\n\t\t\ttypeSection.push(0)\n\t\t} else {\n\t\t\ttypeSection = typeSection.concat([1, typeCodes[sigRet]])\n\t\t}\n\t\ttypeSection[1] = typeSection.length - 2;\n\t\tvar bytes = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0].concat(typeSection, [2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0]));\n\t\tvar module = new WebAssembly.Module(bytes);\n\t\tvar instance = new WebAssembly.Instance(module, {\n\t\t\t\"e\": {\n\t\t\t\t\"f\": func\n\t\t\t}\n\t\t});\n\t\tvar wrappedFunc = instance.exports[\"f\"];\n\t\treturn wrappedFunc\n\t}\n\tvar freeTableIndexes = [];\n\tvar functionsInTableMap;\n\n\tfunction addFunctionWasm(func, sig) {\n\t\tvar table = wasmTable;\n\t\tif (!functionsInTableMap) {\n\t\t\tfunctionsInTableMap = new WeakMap;\n\t\t\tfor (var i = 0; i < table.length; i++) {\n\t\t\t\tvar item = table.get(i);\n\t\t\t\tif (item) {\n\t\t\t\t\tfunctionsInTableMap.set(item, i)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (functionsInTableMap.has(func)) {\n\t\t\treturn functionsInTableMap.get(func)\n\t\t}\n\t\tvar ret;\n\t\tif (freeTableIndexes.length) {\n\t\t\tret = freeTableIndexes.pop()\n\t\t} else {\n\t\t\tret = table.length;\n\t\t\ttry {\n\t\t\t\ttable.grow(1)\n\t\t\t} catch (err) {\n\t\t\t\tif (!(err instanceof RangeError)) {\n\t\t\t\t\tthrow err\n\t\t\t\t}\n\t\t\t\tthrow \"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.\"\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\ttable.set(ret, func)\n\t\t} catch (err) {\n\t\t\tif (!(err instanceof TypeError)) {\n\t\t\t\tthrow err\n\t\t\t}\n\t\t\tvar wrapped = convertJsFunctionToWasm(func, sig);\n\t\t\ttable.set(ret, wrapped)\n\t\t}\n\t\tfunctionsInTableMap.set(func, ret);\n\t\treturn ret\n\t}\n\n\tfunction removeFunctionWasm(index) {\n\t\tfunctionsInTableMap.delete(wasmTable.get(index));\n\t\tfreeTableIndexes.push(index)\n\t}\n\tvar funcWrappers = {};\n\n\tfunction dynCall(sig, ptr, args) {\n\t\tif (args && args.length) {\n\t\t\treturn Module[\"dynCall_\" + sig].apply(null, [ptr].concat(args))\n\t\t} else {\n\t\t\treturn Module[\"dynCall_\" + sig].call(null, ptr)\n\t\t}\n\t}\n\tvar tempRet0 = 0;\n\tvar wasmBinary;\n\tif (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n\tvar noExitRuntime;\n\tif (Module[\"noExitRuntime\"]) noExitRuntime = Module[\"noExitRuntime\"];\n\tif (typeof WebAssembly !== \"object\") {\n\t\terr(\"no native wasm support detected\")\n\t}\n\n\tfunction setValue(ptr, value, type, noSafe) {\n\t\ttype = type || \"i8\";\n\t\tif (type.charAt(type.length - 1) === \"*\") type = \"i32\";\n\t\tswitch (type) {\n\t\t\tcase \"i1\":\n\t\t\t\tHEAP8[ptr >> 0] = value;\n\t\t\t\tbreak;\n\t\t\tcase \"i8\":\n\t\t\t\tHEAP8[ptr >> 0] = value;\n\t\t\t\tbreak;\n\t\t\tcase \"i16\":\n\t\t\t\tHEAP16[ptr >> 1] = value;\n\t\t\t\tbreak;\n\t\t\tcase \"i32\":\n\t\t\t\tHEAP32[ptr >> 2] = value;\n\t\t\t\tbreak;\n\t\t\tcase \"i64\":\n\t\t\t\ttempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n\t\t\t\tbreak;\n\t\t\tcase \"float\":\n\t\t\t\tHEAPF32[ptr >> 2] = value;\n\t\t\t\tbreak;\n\t\t\tcase \"double\":\n\t\t\t\tHEAPF64[ptr >> 3] = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort(\"invalid type for setValue: \" + type)\n\t\t}\n\t}\n\tvar wasmMemory;\n\tvar wasmTable = new WebAssembly.Table({\n\t\t\"initial\": 247,\n\t\t\"maximum\": 247 + 0,\n\t\t\"element\": \"anyfunc\"\n\t});\n\tvar ABORT = false;\n\tvar EXITSTATUS = 0;\n\n\tfunction assert(condition, text) {\n\t\tif (!condition) {\n\t\t\tabort(\"Assertion failed: \" + text)\n\t\t}\n\t}\n\n\tfunction getCFunc(ident) {\n\t\tvar func = Module[\"_\" + ident];\n\t\tassert(func, \"Cannot call unknown function \" + ident + \", make sure it is exported\");\n\t\treturn func\n\t}\n\n\tfunction ccall(ident, returnType, argTypes, args, opts) {\n\t\tvar toC = {\n\t\t\t\"string\": function (str) {\n\t\t\t\tvar ret = 0;\n\t\t\t\tif (str !== null && str !== undefined && str !== 0) {\n\t\t\t\t\tvar len = (str.length << 2) + 1;\n\t\t\t\t\tret = stackAlloc(len);\n\t\t\t\t\tstringToUTF8(str, ret, len)\n\t\t\t\t}\n\t\t\t\treturn ret\n\t\t\t},\n\t\t\t\"array\": function (arr) {\n\t\t\t\tvar ret = stackAlloc(arr.length);\n\t\t\t\twriteArrayToMemory(arr, ret);\n\t\t\t\treturn ret\n\t\t\t}\n\t\t};\n\n\t\tfunction convertReturnValue(ret) {\n\t\t\tif (returnType === \"string\") return UTF8ToString(ret);\n\t\t\tif (returnType === \"boolean\") return Boolean(ret);\n\t\t\treturn ret\n\t\t}\n\t\tvar func = getCFunc(ident);\n\t\tvar cArgs = [];\n\t\tvar stack = 0;\n\t\tif (args) {\n\t\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\t\tvar converter = toC[argTypes[i]];\n\t\t\t\tif (converter) {\n\t\t\t\t\tif (stack === 0) stack = stackSave();\n\t\t\t\t\tcArgs[i] = converter(args[i])\n\t\t\t\t} else {\n\t\t\t\t\tcArgs[i] = args[i]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar ret = func.apply(null, cArgs);\n\t\tret = convertReturnValue(ret);\n\t\tif (stack !== 0) stackRestore(stack);\n\t\treturn ret\n\t}\n\tvar ALLOC_NONE = 3;\n\tvar UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\n\tfunction UTF8ArrayToString(heap, idx, maxBytesToRead) {\n\t\tvar endIdx = idx + maxBytesToRead;\n\t\tvar endPtr = idx;\n\t\twhile (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\t\tif (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n\t\t\treturn UTF8Decoder.decode(heap.subarray(idx, endPtr))\n\t\t} else {\n\t\t\tvar str = \"\";\n\t\t\twhile (idx < endPtr) {\n\t\t\t\tvar u0 = heap[idx++];\n\t\t\t\tif (!(u0 & 128)) {\n\t\t\t\t\tstr += String.fromCharCode(u0);\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tvar u1 = heap[idx++] & 63;\n\t\t\t\tif ((u0 & 224) == 192) {\n\t\t\t\t\tstr += String.fromCharCode((u0 & 31) << 6 | u1);\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tvar u2 = heap[idx++] & 63;\n\t\t\t\tif ((u0 & 240) == 224) {\n\t\t\t\t\tu0 = (u0 & 15) << 12 | u1 << 6 | u2\n\t\t\t\t} else {\n\t\t\t\t\tu0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63\n\t\t\t\t}\n\t\t\t\tif (u0 < 65536) {\n\t\t\t\t\tstr += String.fromCharCode(u0)\n\t\t\t\t} else {\n\t\t\t\t\tvar ch = u0 - 65536;\n\t\t\t\t\tstr += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn str\n\t}\n\n\tfunction UTF8ToString(ptr, maxBytesToRead) {\n\t\treturn ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\"\n\t}\n\n\tfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n\t\tif (!(maxBytesToWrite > 0)) return 0;\n\t\tvar startIdx = outIdx;\n\t\tvar endIdx = outIdx + maxBytesToWrite - 1;\n\t\tfor (var i = 0; i < str.length; ++i) {\n\t\t\tvar u = str.charCodeAt(i);\n\t\t\tif (u >= 55296 && u <= 57343) {\n\t\t\t\tvar u1 = str.charCodeAt(++i);\n\t\t\t\tu = 65536 + ((u & 1023) << 10) | u1 & 1023\n\t\t\t}\n\t\t\tif (u <= 127) {\n\t\t\t\tif (outIdx >= endIdx) break;\n\t\t\t\theap[outIdx++] = u\n\t\t\t} else if (u <= 2047) {\n\t\t\t\tif (outIdx + 1 >= endIdx) break;\n\t\t\t\theap[outIdx++] = 192 | u >> 6;\n\t\t\t\theap[outIdx++] = 128 | u & 63\n\t\t\t} else if (u <= 65535) {\n\t\t\t\tif (outIdx + 2 >= endIdx) break;\n\t\t\t\theap[outIdx++] = 224 | u >> 12;\n\t\t\t\theap[outIdx++] = 128 | u >> 6 & 63;\n\t\t\t\theap[outIdx++] = 128 | u & 63\n\t\t\t} else {\n\t\t\t\tif (outIdx + 3 >= endIdx) break;\n\t\t\t\theap[outIdx++] = 240 | u >> 18;\n\t\t\t\theap[outIdx++] = 128 | u >> 12 & 63;\n\t\t\t\theap[outIdx++] = 128 | u >> 6 & 63;\n\t\t\t\theap[outIdx++] = 128 | u & 63\n\t\t\t}\n\t\t}\n\t\theap[outIdx] = 0;\n\t\treturn outIdx - startIdx\n\t}\n\n\tfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n\t\treturn stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite)\n\t}\n\n\tfunction lengthBytesUTF8(str) {\n\t\tvar len = 0;\n\t\tfor (var i = 0; i < str.length; ++i) {\n\t\t\tvar u = str.charCodeAt(i);\n\t\t\tif (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n\t\t\tif (u <= 127) ++len;\n\t\t\telse if (u <= 2047) len += 2;\n\t\t\telse if (u <= 65535) len += 3;\n\t\t\telse len += 4\n\t\t}\n\t\treturn len\n\t}\n\tvar UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n\n\tfunction UTF16ToString(ptr, maxBytesToRead) {\n\t\tvar endPtr = ptr;\n\t\tvar idx = endPtr >> 1;\n\t\tvar maxIdx = idx + maxBytesToRead / 2;\n\t\twhile (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\n\t\tendPtr = idx << 1;\n\t\tif (endPtr - ptr > 32 && UTF16Decoder) {\n\t\t\treturn UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr))\n\t\t} else {\n\t\t\tvar i = 0;\n\t\t\tvar str = \"\";\n\t\t\twhile (1) {\n\t\t\t\tvar codeUnit = HEAP16[ptr + i * 2 >> 1];\n\t\t\t\tif (codeUnit == 0 || i == maxBytesToRead / 2) return str;\n\t\t\t\t++i;\n\t\t\t\tstr += String.fromCharCode(codeUnit)\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n\t\tif (maxBytesToWrite === undefined) {\n\t\t\tmaxBytesToWrite = 2147483647\n\t\t}\n\t\tif (maxBytesToWrite < 2) return 0;\n\t\tmaxBytesToWrite -= 2;\n\t\tvar startPtr = outPtr;\n\t\tvar numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n\t\tfor (var i = 0; i < numCharsToWrite; ++i) {\n\t\t\tvar codeUnit = str.charCodeAt(i);\n\t\t\tHEAP16[outPtr >> 1] = codeUnit;\n\t\t\toutPtr += 2\n\t\t}\n\t\tHEAP16[outPtr >> 1] = 0;\n\t\treturn outPtr - startPtr\n\t}\n\n\tfunction lengthBytesUTF16(str) {\n\t\treturn str.length * 2\n\t}\n\n\tfunction UTF32ToString(ptr, maxBytesToRead) {\n\t\tvar i = 0;\n\t\tvar str = \"\";\n\t\twhile (!(i >= maxBytesToRead / 4)) {\n\t\t\tvar utf32 = HEAP32[ptr + i * 4 >> 2];\n\t\t\tif (utf32 == 0) break;\n\t\t\t++i;\n\t\t\tif (utf32 >= 65536) {\n\t\t\t\tvar ch = utf32 - 65536;\n\t\t\t\tstr += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023)\n\t\t\t} else {\n\t\t\t\tstr += String.fromCharCode(utf32)\n\t\t\t}\n\t\t}\n\t\treturn str\n\t}\n\n\tfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n\t\tif (maxBytesToWrite === undefined) {\n\t\t\tmaxBytesToWrite = 2147483647\n\t\t}\n\t\tif (maxBytesToWrite < 4) return 0;\n\t\tvar startPtr = outPtr;\n\t\tvar endPtr = startPtr + maxBytesToWrite - 4;\n\t\tfor (var i = 0; i < str.length; ++i) {\n\t\t\tvar codeUnit = str.charCodeAt(i);\n\t\t\tif (codeUnit >= 55296 && codeUnit <= 57343) {\n\t\t\t\tvar trailSurrogate = str.charCodeAt(++i);\n\t\t\t\tcodeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023\n\t\t\t}\n\t\t\tHEAP32[outPtr >> 2] = codeUnit;\n\t\t\toutPtr += 4;\n\t\t\tif (outPtr + 4 > endPtr) break\n\t\t}\n\t\tHEAP32[outPtr >> 2] = 0;\n\t\treturn outPtr - startPtr\n\t}\n\n\tfunction lengthBytesUTF32(str) {\n\t\tvar len = 0;\n\t\tfor (var i = 0; i < str.length; ++i) {\n\t\t\tvar codeUnit = str.charCodeAt(i);\n\t\t\tif (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n\t\t\tlen += 4\n\t\t}\n\t\treturn len\n\t}\n\n\tfunction writeArrayToMemory(array, buffer) {\n\t\tHEAP8.set(array, buffer)\n\t}\n\n\tfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n\t\tfor (var i = 0; i < str.length; ++i) {\n\t\t\tHEAP8[buffer++ >> 0] = str.charCodeAt(i)\n\t\t}\n\t\tif (!dontAddNull) HEAP8[buffer >> 0] = 0\n\t}\n\tvar WASM_PAGE_SIZE = 65536;\n\n\tfunction alignUp(x, multiple) {\n\t\tif (x % multiple > 0) {\n\t\t\tx += multiple - x % multiple\n\t\t}\n\t\treturn x\n\t}\n\tvar buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\n\tfunction updateGlobalBufferAndViews(buf) {\n\t\tbuffer = buf;\n\t\tModule[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\n\t\tModule[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\n\t\tModule[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\n\t\tModule[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\n\t\tModule[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\n\t\tModule[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\n\t\tModule[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\n\t\tModule[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf)\n\t}\n\tvar STACK_BASE = 5288688,\n\t\tDYNAMIC_BASE = 5288688,\n\t\tDYNAMICTOP_PTR = 45648;\n\tvar INITIAL_INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 1073741824;\n\tif (Module[\"wasmMemory\"]) {\n\t\twasmMemory = Module[\"wasmMemory\"]\n\t} else {\n\t\twasmMemory = new WebAssembly.Memory({\n\t\t\t\"initial\": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,\n\t\t\t\"maximum\": 2147483648 / WASM_PAGE_SIZE\n\t\t})\n\t}\n\tif (wasmMemory) {\n\t\tbuffer = wasmMemory.buffer\n\t}\n\tINITIAL_INITIAL_MEMORY = buffer.byteLength;\n\tupdateGlobalBufferAndViews(buffer);\n\tHEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\n\n\tfunction callRuntimeCallbacks(callbacks) {\n\t\twhile (callbacks.length > 0) {\n\t\t\tvar callback = callbacks.shift();\n\t\t\tif (typeof callback == \"function\") {\n\t\t\t\tcallback(Module);\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar func = callback.func;\n\t\t\tif (typeof func === \"number\") {\n\t\t\t\tif (callback.arg === undefined) {\n\t\t\t\t\tModule[\"dynCall_v\"](func)\n\t\t\t\t} else {\n\t\t\t\t\tModule[\"dynCall_vi\"](func, callback.arg)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfunc(callback.arg === undefined ? null : callback.arg)\n\t\t\t}\n\t\t}\n\t}\n\tvar __ATPRERUN__ = [];\n\tvar __ATINIT__ = [];\n\tvar __ATMAIN__ = [];\n\tvar __ATEXIT__ = [];\n\tvar __ATPOSTRUN__ = [];\n\tvar runtimeInitialized = false;\n\tvar runtimeExited = false;\n\n\tfunction preRun() {\n\t\tif (Module[\"preRun\"]) {\n\t\t\tif (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n\t\t\twhile (Module[\"preRun\"].length) {\n\t\t\t\taddOnPreRun(Module[\"preRun\"].shift())\n\t\t\t}\n\t\t}\n\t\tcallRuntimeCallbacks(__ATPRERUN__)\n\t}\n\n\tfunction initRuntime() {\n\t\truntimeInitialized = true;\n\t\tcallRuntimeCallbacks(__ATINIT__)\n\t}\n\n\tfunction preMain() {\n\t\tcallRuntimeCallbacks(__ATMAIN__)\n\t}\n\n\tfunction exitRuntime() {\n\t\truntimeExited = true\n\t}\n\n\tfunction postRun() {\n\t\tif (Module[\"postRun\"]) {\n\t\t\tif (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n\t\t\twhile (Module[\"postRun\"].length) {\n\t\t\t\taddOnPostRun(Module[\"postRun\"].shift())\n\t\t\t}\n\t\t}\n\t\tcallRuntimeCallbacks(__ATPOSTRUN__)\n\t}\n\n\tfunction addOnPreRun(cb) {\n\t\t__ATPRERUN__.unshift(cb)\n\t}\n\n\tfunction addOnPostRun(cb) {\n\t\t__ATPOSTRUN__.unshift(cb)\n\t}\n\tvar Math_abs = Math.abs;\n\tvar Math_ceil = Math.ceil;\n\tvar Math_floor = Math.floor;\n\tvar Math_min = Math.min;\n\tvar runDependencies = 0;\n\tvar runDependencyWatcher = null;\n\tvar dependenciesFulfilled = null;\n\n\tfunction addRunDependency(id) {\n\t\trunDependencies++;\n\t\tif (Module[\"monitorRunDependencies\"]) {\n\t\t\tModule[\"monitorRunDependencies\"](runDependencies)\n\t\t}\n\t}\n\n\tfunction removeRunDependency(id) {\n\t\trunDependencies--;\n\t\tif (Module[\"monitorRunDependencies\"]) {\n\t\t\tModule[\"monitorRunDependencies\"](runDependencies)\n\t\t}\n\t\tif (runDependencies == 0) {\n\t\t\tif (runDependencyWatcher !== null) {\n\t\t\t\tclearInterval(runDependencyWatcher);\n\t\t\t\trunDependencyWatcher = null\n\t\t\t}\n\t\t\tif (dependenciesFulfilled) {\n\t\t\t\tvar callback = dependenciesFulfilled;\n\t\t\t\tdependenciesFulfilled = null;\n\t\t\t\tcallback()\n\t\t\t}\n\t\t}\n\t}\n\tModule[\"preloadedImages\"] = {};\n\tModule[\"preloadedAudios\"] = {};\n\n\tfunction abort(what) {\n\t\tif (Module[\"onAbort\"]) {\n\t\t\tModule[\"onAbort\"](what)\n\t\t}\n\t\twhat += \"\";\n\t\tout(what);\n\t\terr(what);\n\t\tABORT = true;\n\t\tEXITSTATUS = 1;\n\t\twhat = \"abort(\" + what + \"). Build with -s ASSERTIONS=1 for more info.\";\n\t\tthrow new WebAssembly.RuntimeError(what)\n\t}\n\n\tfunction hasPrefix(str, prefix) {\n\t\treturn String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0\n\t}\n\tvar dataURIPrefix = \"data:application/octet-stream;base64,\";\n\n\tfunction isDataURI(filename) {\n\t\treturn hasPrefix(filename, dataURIPrefix)\n\t}\n\tvar fileURIPrefix = \"file://\";\n\n\tfunction isFileURI(filename) {\n\t\treturn hasPrefix(filename, fileURIPrefix)\n\t}\n\tvar wasmBinaryFile = ENVIRONMENT_IS_NODE && \"charlsjs.wasm\" || raw(\"./charLSjs.wasm.base64\");\n\tif (!isDataURI(wasmBinaryFile)) {\n\t\twasmBinaryFile = locateFile(wasmBinaryFile)\n\t}\n\n\tfunction getBinary() {\n\t\ttry {\n\t\t\tif (wasmBinary) {\n\t\t\t\treturn new Uint8Array(wasmBinary)\n\t\t\t}\n\t\t\tif (readBinary) {\n\t\t\t\treturn readBinary(wasmBinaryFile)\n\t\t\t} else {\n\t\t\t\tthrow \"both async and sync fetching of the wasm failed\"\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tabort(err)\n\t\t}\n\t}\n\n\tfunction getBinaryPromise() {\n\t\tif (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === \"function\" && !isFileURI(wasmBinaryFile)) {\n\t\t\treturn fetch(wasmBinaryFile, {\n\t\t\t\tcredentials: \"same-origin\"\n\t\t\t}).then(function (response) {\n\t\t\t\tif (!response[\"ok\"]) {\n\t\t\t\t\tthrow \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\"\n\t\t\t\t}\n\t\t\t\treturn response[\"arrayBuffer\"]()\n\t\t\t}).catch(function () {\n\t\t\t\treturn getBinary()\n\t\t\t})\n\t\t}\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tresolve(getBinary())\n\t\t})\n\t}\n\n\tfunction createWasm() {\n\t\tvar info = {\n\t\t\t\"env\": asmLibraryArg,\n\t\t\t\"wasi_snapshot_preview1\": asmLibraryArg\n\t\t};\n\n\t\tfunction receiveInstance(instance, module) {\n\t\t\tvar exports = instance.exports;\n\t\t\tModule[\"asm\"] = exports;\n\t\t\tremoveRunDependency(\"wasm-instantiate\")\n\t\t}\n\t\taddRunDependency(\"wasm-instantiate\");\n\n\t\tfunction receiveInstantiatedSource(output) {\n\t\t\treceiveInstance(output[\"instance\"])\n\t\t}\n\n\t\tfunction instantiateArrayBuffer(receiver) {\n\t\t\treturn getBinaryPromise().then(function (binary) {\n\t\t\t\treturn WebAssembly.instantiate(binary, info)\n\t\t\t}).then(receiver, function (reason) {\n\t\t\t\terr(\"failed to asynchronously prepare wasm: \" + reason);\n\t\t\t\tabort(reason)\n\t\t\t})\n\t\t}\n\n\t\tfunction instantiateAsync() {\n\t\t\tif (!wasmBinary && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === \"function\") {\n\t\t\t\tfetch(wasmBinaryFile, {\n\t\t\t\t\tcredentials: \"same-origin\"\n\t\t\t\t}).then(function (response) {\n\t\t\t\t\tvar result = WebAssembly.instantiateStreaming(response, info);\n\t\t\t\t\treturn result.then(receiveInstantiatedSource, function (reason) {\n\t\t\t\t\t\terr(\"wasm streaming compile failed: \" + reason);\n\t\t\t\t\t\terr(\"falling back to ArrayBuffer instantiation\");\n\t\t\t\t\t\treturn instantiateArrayBuffer(receiveInstantiatedSource)\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn instantiateArrayBuffer(receiveInstantiatedSource)\n\t\t\t}\n\t\t}\n\t\tif (Module[\"instantiateWasm\"]) {\n\t\t\ttry {\n\t\t\t\tvar exports = Module[\"instantiateWasm\"](info, receiveInstance);\n\t\t\t\treturn exports\n\t\t\t} catch (e) {\n\t\t\t\terr(\"Module.instantiateWasm callback failed with error: \" + e);\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tinstantiateAsync();\n\t\treturn {}\n\t}\n\tvar tempDouble;\n\tvar tempI64;\n\t__ATINIT__.push({\n\t\tfunc: function () {\n\t\t\t___wasm_call_ctors()\n\t\t}\n\t});\n\n\tfunction demangle(func) {\n\t\treturn func\n\t}\n\n\tfunction demangleAll(text) {\n\t\tvar regex = /\\b_Z[\\w\\d_]+/g;\n\t\treturn text.replace(regex, function (x) {\n\t\t\tvar y = demangle(x);\n\t\t\treturn x === y ? x : y + \" [\" + x + \"]\"\n\t\t})\n\t}\n\n\tfunction jsStackTrace() {\n\t\tvar err = new Error;\n\t\tif (!err.stack) {\n\t\t\ttry {\n\t\t\t\tthrow new Error\n\t\t\t} catch (e) {\n\t\t\t\terr = e\n\t\t\t}\n\t\t\tif (!err.stack) {\n\t\t\t\treturn \"(no stack trace available)\"\n\t\t\t}\n\t\t}\n\t\treturn err.stack.toString()\n\t}\n\n\tfunction ___cxa_allocate_exception(size) {\n\t\treturn _malloc(size)\n\t}\n\n\tfunction _atexit(func, arg) {\n\t\t__ATEXIT__.unshift({\n\t\t\tfunc: func,\n\t\t\targ: arg\n\t\t})\n\t}\n\n\tfunction ___cxa_atexit(a0, a1) {\n\t\treturn _atexit(a0, a1)\n\t}\n\tvar ___exception_infos = {};\n\tvar ___exception_last = 0;\n\n\tfunction __ZSt18uncaught_exceptionv() {\n\t\treturn __ZSt18uncaught_exceptionv.uncaught_exceptions > 0\n\t}\n\n\tfunction ___cxa_throw(ptr, type, destructor) {\n\t\t___exception_infos[ptr] = {\n\t\t\tptr: ptr,\n\t\t\tadjusted: [ptr],\n\t\t\ttype: type,\n\t\t\tdestructor: destructor,\n\t\t\trefcount: 0,\n\t\t\tcaught: false,\n\t\t\trethrown: false\n\t\t};\n\t\t___exception_last = ptr;\n\t\tif (!(\"uncaught_exception\" in __ZSt18uncaught_exceptionv)) {\n\t\t\t__ZSt18uncaught_exceptionv.uncaught_exceptions = 1\n\t\t} else {\n\t\t\t__ZSt18uncaught_exceptionv.uncaught_exceptions++\n\t\t}\n\t\tthrow ptr\n\t}\n\tvar structRegistrations = {};\n\n\tfunction runDestructors(destructors) {\n\t\twhile (destructors.length) {\n\t\t\tvar ptr = destructors.pop();\n\t\t\tvar del = destructors.pop();\n\t\t\tdel(ptr)\n\t\t}\n\t}\n\n\tfunction simpleReadValueFromPointer(pointer) {\n\t\treturn this[\"fromWireType\"](HEAPU32[pointer >> 2])\n\t}\n\tvar awaitingDependencies = {};\n\tvar registeredTypes = {};\n\tvar typeDependencies = {};\n\tvar char_0 = 48;\n\tvar char_9 = 57;\n\n\tfunction makeLegalFunctionName(name) {\n\t\tif (undefined === name) {\n\t\t\treturn \"_unknown\"\n\t\t}\n\t\tname = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n\t\tvar f = name.charCodeAt(0);\n\t\tif (f >= char_0 && f <= char_9) {\n\t\t\treturn \"_\" + name\n\t\t} else {\n\t\t\treturn name\n\t\t}\n\t}\n\n\tfunction createNamedFunction(name, body) {\n\t\tname = makeLegalFunctionName(name);\n\t\treturn new Function(\"body\", \"return function \" + name + \"() {\\n\" + '    \"use strict\";' + \"    return body.apply(this, arguments);\\n\" + \"};\\n\")(body)\n\t}\n\n\tfunction extendError(baseErrorType, errorName) {\n\t\tvar errorClass = createNamedFunction(errorName, function (message) {\n\t\t\tthis.name = errorName;\n\t\t\tthis.message = message;\n\t\t\tvar stack = new Error(message).stack;\n\t\t\tif (stack !== undefined) {\n\t\t\t\tthis.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\")\n\t\t\t}\n\t\t});\n\t\terrorClass.prototype = Object.create(baseErrorType.prototype);\n\t\terrorClass.prototype.constructor = errorClass;\n\t\terrorClass.prototype.toString = function () {\n\t\t\tif (this.message === undefined) {\n\t\t\t\treturn this.name\n\t\t\t} else {\n\t\t\t\treturn this.name + \": \" + this.message\n\t\t\t}\n\t\t};\n\t\treturn errorClass\n\t}\n\tvar InternalError = undefined;\n\n\tfunction throwInternalError(message) {\n\t\tthrow new InternalError(message)\n\t}\n\n\tfunction whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n\t\tmyTypes.forEach(function (type) {\n\t\t\ttypeDependencies[type] = dependentTypes\n\t\t});\n\n\t\tfunction onComplete(typeConverters) {\n\t\t\tvar myTypeConverters = getTypeConverters(typeConverters);\n\t\t\tif (myTypeConverters.length !== myTypes.length) {\n\t\t\t\tthrowInternalError(\"Mismatched type converter count\")\n\t\t\t}\n\t\t\tfor (var i = 0; i < myTypes.length; ++i) {\n\t\t\t\tregisterType(myTypes[i], myTypeConverters[i])\n\t\t\t}\n\t\t}\n\t\tvar typeConverters = new Array(dependentTypes.length);\n\t\tvar unregisteredTypes = [];\n\t\tvar registered = 0;\n\t\tdependentTypes.forEach(function (dt, i) {\n\t\t\tif (registeredTypes.hasOwnProperty(dt)) {\n\t\t\t\ttypeConverters[i] = registeredTypes[dt]\n\t\t\t} else {\n\t\t\t\tunregisteredTypes.push(dt);\n\t\t\t\tif (!awaitingDependencies.hasOwnProperty(dt)) {\n\t\t\t\t\tawaitingDependencies[dt] = []\n\t\t\t\t}\n\t\t\t\tawaitingDependencies[dt].push(function () {\n\t\t\t\t\ttypeConverters[i] = registeredTypes[dt];\n\t\t\t\t\t++registered;\n\t\t\t\t\tif (registered === unregisteredTypes.length) {\n\t\t\t\t\t\tonComplete(typeConverters)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t});\n\t\tif (0 === unregisteredTypes.length) {\n\t\t\tonComplete(typeConverters)\n\t\t}\n\t}\n\n\tfunction __embind_finalize_value_object(structType) {\n\t\tvar reg = structRegistrations[structType];\n\t\tdelete structRegistrations[structType];\n\t\tvar rawConstructor = reg.rawConstructor;\n\t\tvar rawDestructor = reg.rawDestructor;\n\t\tvar fieldRecords = reg.fields;\n\t\tvar fieldTypes = fieldRecords.map(function (field) {\n\t\t\treturn field.getterReturnType\n\t\t}).concat(fieldRecords.map(function (field) {\n\t\t\treturn field.setterArgumentType\n\t\t}));\n\t\twhenDependentTypesAreResolved([structType], fieldTypes, function (fieldTypes) {\n\t\t\tvar fields = {};\n\t\t\tfieldRecords.forEach(function (field, i) {\n\t\t\t\tvar fieldName = field.fieldName;\n\t\t\t\tvar getterReturnType = fieldTypes[i];\n\t\t\t\tvar getter = field.getter;\n\t\t\t\tvar getterContext = field.getterContext;\n\t\t\t\tvar setterArgumentType = fieldTypes[i + fieldRecords.length];\n\t\t\t\tvar setter = field.setter;\n\t\t\t\tvar setterContext = field.setterContext;\n\t\t\t\tfields[fieldName] = {\n\t\t\t\t\tread: function (ptr) {\n\t\t\t\t\t\treturn getterReturnType[\"fromWireType\"](getter(getterContext, ptr))\n\t\t\t\t\t},\n\t\t\t\t\twrite: function (ptr, o) {\n\t\t\t\t\t\tvar destructors = [];\n\t\t\t\t\t\tsetter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n\t\t\t\t\t\trunDestructors(destructors)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn [{\n\t\t\t\tname: reg.name,\n\t\t\t\t\"fromWireType\": function (ptr) {\n\t\t\t\t\tvar rv = {};\n\t\t\t\t\tfor (var i in fields) {\n\t\t\t\t\t\trv[i] = fields[i].read(ptr)\n\t\t\t\t\t}\n\t\t\t\t\trawDestructor(ptr);\n\t\t\t\t\treturn rv\n\t\t\t\t},\n\t\t\t\t\"toWireType\": function (destructors, o) {\n\t\t\t\t\tfor (var fieldName in fields) {\n\t\t\t\t\t\tif (!(fieldName in o)) {\n\t\t\t\t\t\t\tthrow new TypeError('Missing field:  \"' + fieldName + '\"')\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar ptr = rawConstructor();\n\t\t\t\t\tfor (fieldName in fields) {\n\t\t\t\t\t\tfields[fieldName].write(ptr, o[fieldName])\n\t\t\t\t\t}\n\t\t\t\t\tif (destructors !== null) {\n\t\t\t\t\t\tdestructors.push(rawDestructor, ptr)\n\t\t\t\t\t}\n\t\t\t\t\treturn ptr\n\t\t\t\t},\n\t\t\t\t\"argPackAdvance\": 8,\n\t\t\t\t\"readValueFromPointer\": simpleReadValueFromPointer,\n\t\t\t\tdestructorFunction: rawDestructor\n\t\t\t}]\n\t\t})\n\t}\n\n\tfunction getShiftFromSize(size) {\n\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\treturn 0;\n\t\t\tcase 2:\n\t\t\t\treturn 1;\n\t\t\tcase 4:\n\t\t\t\treturn 2;\n\t\t\tcase 8:\n\t\t\t\treturn 3;\n\t\t\tdefault:\n\t\t\t\tthrow new TypeError(\"Unknown type size: \" + size)\n\t\t}\n\t}\n\n\tfunction embind_init_charCodes() {\n\t\tvar codes = new Array(256);\n\t\tfor (var i = 0; i < 256; ++i) {\n\t\t\tcodes[i] = String.fromCharCode(i)\n\t\t}\n\t\tembind_charCodes = codes\n\t}\n\tvar embind_charCodes = undefined;\n\n\tfunction readLatin1String(ptr) {\n\t\tvar ret = \"\";\n\t\tvar c = ptr;\n\t\twhile (HEAPU8[c]) {\n\t\t\tret += embind_charCodes[HEAPU8[c++]]\n\t\t}\n\t\treturn ret\n\t}\n\tvar BindingError = undefined;\n\n\tfunction throwBindingError(message) {\n\t\tthrow new BindingError(message)\n\t}\n\n\tfunction registerType(rawType, registeredInstance, options) {\n\t\toptions = options || {};\n\t\tif (!(\"argPackAdvance\" in registeredInstance)) {\n\t\t\tthrow new TypeError(\"registerType registeredInstance requires argPackAdvance\")\n\t\t}\n\t\tvar name = registeredInstance.name;\n\t\tif (!rawType) {\n\t\t\tthrowBindingError('type \"' + name + '\" must have a positive integer typeid pointer')\n\t\t}\n\t\tif (registeredTypes.hasOwnProperty(rawType)) {\n\t\t\tif (options.ignoreDuplicateRegistrations) {\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tthrowBindingError(\"Cannot register type '\" + name + \"' twice\")\n\t\t\t}\n\t\t}\n\t\tregisteredTypes[rawType] = registeredInstance;\n\t\tdelete typeDependencies[rawType];\n\t\tif (awaitingDependencies.hasOwnProperty(rawType)) {\n\t\t\tvar callbacks = awaitingDependencies[rawType];\n\t\t\tdelete awaitingDependencies[rawType];\n\t\t\tcallbacks.forEach(function (cb) {\n\t\t\t\tcb()\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n\t\tvar shift = getShiftFromSize(size);\n\t\tname = readLatin1String(name);\n\t\tregisterType(rawType, {\n\t\t\tname: name,\n\t\t\t\"fromWireType\": function (wt) {\n\t\t\t\treturn !!wt\n\t\t\t},\n\t\t\t\"toWireType\": function (destructors, o) {\n\t\t\t\treturn o ? trueValue : falseValue\n\t\t\t},\n\t\t\t\"argPackAdvance\": 8,\n\t\t\t\"readValueFromPointer\": function (pointer) {\n\t\t\t\tvar heap;\n\t\t\t\tif (size === 1) {\n\t\t\t\t\theap = HEAP8\n\t\t\t\t} else if (size === 2) {\n\t\t\t\t\theap = HEAP16\n\t\t\t\t} else if (size === 4) {\n\t\t\t\t\theap = HEAP32\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError(\"Unknown boolean type size: \" + name)\n\t\t\t\t}\n\t\t\t\treturn this[\"fromWireType\"](heap[pointer >> shift])\n\t\t\t},\n\t\t\tdestructorFunction: null\n\t\t})\n\t}\n\n\tfunction ClassHandle_isAliasOf(other) {\n\t\tif (!(this instanceof ClassHandle)) {\n\t\t\treturn false\n\t\t}\n\t\tif (!(other instanceof ClassHandle)) {\n\t\t\treturn false\n\t\t}\n\t\tvar leftClass = this.$$.ptrType.registeredClass;\n\t\tvar left = this.$$.ptr;\n\t\tvar rightClass = other.$$.ptrType.registeredClass;\n\t\tvar right = other.$$.ptr;\n\t\twhile (leftClass.baseClass) {\n\t\t\tleft = leftClass.upcast(left);\n\t\t\tleftClass = leftClass.baseClass\n\t\t}\n\t\twhile (rightClass.baseClass) {\n\t\t\tright = rightClass.upcast(right);\n\t\t\trightClass = rightClass.baseClass\n\t\t}\n\t\treturn leftClass === rightClass && left === right\n\t}\n\n\tfunction shallowCopyInternalPointer(o) {\n\t\treturn {\n\t\t\tcount: o.count,\n\t\t\tdeleteScheduled: o.deleteScheduled,\n\t\t\tpreservePointerOnDelete: o.preservePointerOnDelete,\n\t\t\tptr: o.ptr,\n\t\t\tptrType: o.ptrType,\n\t\t\tsmartPtr: o.smartPtr,\n\t\t\tsmartPtrType: o.smartPtrType\n\t\t}\n\t}\n\n\tfunction throwInstanceAlreadyDeleted(obj) {\n\t\tfunction getInstanceTypeName(handle) {\n\t\t\treturn handle.$$.ptrType.registeredClass.name\n\t\t}\n\t\tthrowBindingError(getInstanceTypeName(obj) + \" instance already deleted\")\n\t}\n\tvar finalizationGroup = false;\n\n\tfunction detachFinalizer(handle) {}\n\n\tfunction runDestructor($$) {\n\t\tif ($$.smartPtr) {\n\t\t\t$$.smartPtrType.rawDestructor($$.smartPtr)\n\t\t} else {\n\t\t\t$$.ptrType.registeredClass.rawDestructor($$.ptr)\n\t\t}\n\t}\n\n\tfunction releaseClassHandle($$) {\n\t\t$$.count.value -= 1;\n\t\tvar toDelete = 0 === $$.count.value;\n\t\tif (toDelete) {\n\t\t\trunDestructor($$)\n\t\t}\n\t}\n\n\tfunction attachFinalizer(handle) {\n\t\tif (\"undefined\" === typeof FinalizationGroup) {\n\t\t\tattachFinalizer = function (handle) {\n\t\t\t\treturn handle\n\t\t\t};\n\t\t\treturn handle\n\t\t}\n\t\tfinalizationGroup = new FinalizationGroup(function (iter) {\n\t\t\tfor (var result = iter.next(); !result.done; result = iter.next()) {\n\t\t\t\tvar $$ = result.value;\n\t\t\t\tif (!$$.ptr) {\n\t\t\t\t\tconsole.warn(\"object already deleted: \" + $$.ptr)\n\t\t\t\t} else {\n\t\t\t\t\treleaseClassHandle($$)\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tattachFinalizer = function (handle) {\n\t\t\tfinalizationGroup.register(handle, handle.$$, handle.$$);\n\t\t\treturn handle\n\t\t};\n\t\tdetachFinalizer = function (handle) {\n\t\t\tfinalizationGroup.unregister(handle.$$)\n\t\t};\n\t\treturn attachFinalizer(handle)\n\t}\n\n\tfunction ClassHandle_clone() {\n\t\tif (!this.$$.ptr) {\n\t\t\tthrowInstanceAlreadyDeleted(this)\n\t\t}\n\t\tif (this.$$.preservePointerOnDelete) {\n\t\t\tthis.$$.count.value += 1;\n\t\t\treturn this\n\t\t} else {\n\t\t\tvar clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n\t\t\t\t$$: {\n\t\t\t\t\tvalue: shallowCopyInternalPointer(this.$$)\n\t\t\t\t}\n\t\t\t}));\n\t\t\tclone.$$.count.value += 1;\n\t\t\tclone.$$.deleteScheduled = false;\n\t\t\treturn clone\n\t\t}\n\t}\n\n\tfunction ClassHandle_delete() {\n\t\tif (!this.$$.ptr) {\n\t\t\tthrowInstanceAlreadyDeleted(this)\n\t\t}\n\t\tif (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n\t\t\tthrowBindingError(\"Object already scheduled for deletion\")\n\t\t}\n\t\tdetachFinalizer(this);\n\t\treleaseClassHandle(this.$$);\n\t\tif (!this.$$.preservePointerOnDelete) {\n\t\t\tthis.$$.smartPtr = undefined;\n\t\t\tthis.$$.ptr = undefined\n\t\t}\n\t}\n\n\tfunction ClassHandle_isDeleted() {\n\t\treturn !this.$$.ptr\n\t}\n\tvar delayFunction = undefined;\n\tvar deletionQueue = [];\n\n\tfunction flushPendingDeletes() {\n\t\twhile (deletionQueue.length) {\n\t\t\tvar obj = deletionQueue.pop();\n\t\t\tobj.$$.deleteScheduled = false;\n\t\t\tobj[\"delete\"]()\n\t\t}\n\t}\n\n\tfunction ClassHandle_deleteLater() {\n\t\tif (!this.$$.ptr) {\n\t\t\tthrowInstanceAlreadyDeleted(this)\n\t\t}\n\t\tif (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n\t\t\tthrowBindingError(\"Object already scheduled for deletion\")\n\t\t}\n\t\tdeletionQueue.push(this);\n\t\tif (deletionQueue.length === 1 && delayFunction) {\n\t\t\tdelayFunction(flushPendingDeletes)\n\t\t}\n\t\tthis.$$.deleteScheduled = true;\n\t\treturn this\n\t}\n\n\tfunction init_ClassHandle() {\n\t\tClassHandle.prototype[\"isAliasOf\"] = ClassHandle_isAliasOf;\n\t\tClassHandle.prototype[\"clone\"] = ClassHandle_clone;\n\t\tClassHandle.prototype[\"delete\"] = ClassHandle_delete;\n\t\tClassHandle.prototype[\"isDeleted\"] = ClassHandle_isDeleted;\n\t\tClassHandle.prototype[\"deleteLater\"] = ClassHandle_deleteLater\n\t}\n\n\tfunction ClassHandle() {}\n\tvar registeredPointers = {};\n\n\tfunction ensureOverloadTable(proto, methodName, humanName) {\n\t\tif (undefined === proto[methodName].overloadTable) {\n\t\t\tvar prevFunc = proto[methodName];\n\t\t\tproto[methodName] = function () {\n\t\t\t\tif (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n\t\t\t\t\tthrowBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\")\n\t\t\t\t}\n\t\t\t\treturn proto[methodName].overloadTable[arguments.length].apply(this, arguments)\n\t\t\t};\n\t\t\tproto[methodName].overloadTable = [];\n\t\t\tproto[methodName].overloadTable[prevFunc.argCount] = prevFunc\n\t\t}\n\t}\n\n\tfunction exposePublicSymbol(name, value, numArguments) {\n\t\tif (Module.hasOwnProperty(name)) {\n\t\t\tif (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\n\t\t\t\tthrowBindingError(\"Cannot register public name '\" + name + \"' twice\")\n\t\t\t}\n\t\t\tensureOverloadTable(Module, name, name);\n\t\t\tif (Module.hasOwnProperty(numArguments)) {\n\t\t\t\tthrowBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\")\n\t\t\t}\n\t\t\tModule[name].overloadTable[numArguments] = value\n\t\t} else {\n\t\t\tModule[name] = value;\n\t\t\tif (undefined !== numArguments) {\n\t\t\t\tModule[name].numArguments = numArguments\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n\t\tthis.name = name;\n\t\tthis.constructor = constructor;\n\t\tthis.instancePrototype = instancePrototype;\n\t\tthis.rawDestructor = rawDestructor;\n\t\tthis.baseClass = baseClass;\n\t\tthis.getActualType = getActualType;\n\t\tthis.upcast = upcast;\n\t\tthis.downcast = downcast;\n\t\tthis.pureVirtualFunctions = []\n\t}\n\n\tfunction upcastPointer(ptr, ptrClass, desiredClass) {\n\t\twhile (ptrClass !== desiredClass) {\n\t\t\tif (!ptrClass.upcast) {\n\t\t\t\tthrowBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name)\n\t\t\t}\n\t\t\tptr = ptrClass.upcast(ptr);\n\t\t\tptrClass = ptrClass.baseClass\n\t\t}\n\t\treturn ptr\n\t}\n\n\tfunction constNoSmartPtrRawPointerToWireType(destructors, handle) {\n\t\tif (handle === null) {\n\t\t\tif (this.isReference) {\n\t\t\t\tthrowBindingError(\"null is not a valid \" + this.name)\n\t\t\t}\n\t\t\treturn 0\n\t\t}\n\t\tif (!handle.$$) {\n\t\t\tthrowBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name)\n\t\t}\n\t\tif (!handle.$$.ptr) {\n\t\t\tthrowBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name)\n\t\t}\n\t\tvar handleClass = handle.$$.ptrType.registeredClass;\n\t\tvar ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n\t\treturn ptr\n\t}\n\n\tfunction genericPointerToWireType(destructors, handle) {\n\t\tvar ptr;\n\t\tif (handle === null) {\n\t\t\tif (this.isReference) {\n\t\t\t\tthrowBindingError(\"null is not a valid \" + this.name)\n\t\t\t}\n\t\t\tif (this.isSmartPointer) {\n\t\t\t\tptr = this.rawConstructor();\n\t\t\t\tif (destructors !== null) {\n\t\t\t\t\tdestructors.push(this.rawDestructor, ptr)\n\t\t\t\t}\n\t\t\t\treturn ptr\n\t\t\t} else {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t\tif (!handle.$$) {\n\t\t\tthrowBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name)\n\t\t}\n\t\tif (!handle.$$.ptr) {\n\t\t\tthrowBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name)\n\t\t}\n\t\tif (!this.isConst && handle.$$.ptrType.isConst) {\n\t\t\tthrowBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name)\n\t\t}\n\t\tvar handleClass = handle.$$.ptrType.registeredClass;\n\t\tptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n\t\tif (this.isSmartPointer) {\n\t\t\tif (undefined === handle.$$.smartPtr) {\n\t\t\t\tthrowBindingError(\"Passing raw pointer to smart pointer is illegal\")\n\t\t\t}\n\t\t\tswitch (this.sharingPolicy) {\n\t\t\t\tcase 0:\n\t\t\t\t\tif (handle.$$.smartPtrType === this) {\n\t\t\t\t\t\tptr = handle.$$.smartPtr\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrowBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tptr = handle.$$.smartPtr;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif (handle.$$.smartPtrType === this) {\n\t\t\t\t\t\tptr = handle.$$.smartPtr\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar clonedHandle = handle[\"clone\"]();\n\t\t\t\t\t\tptr = this.rawShare(ptr, __emval_register(function () {\n\t\t\t\t\t\t\tclonedHandle[\"delete\"]()\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tif (destructors !== null) {\n\t\t\t\t\t\t\tdestructors.push(this.rawDestructor, ptr)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrowBindingError(\"Unsupporting sharing policy\")\n\t\t\t}\n\t\t}\n\t\treturn ptr\n\t}\n\n\tfunction nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n\t\tif (handle === null) {\n\t\t\tif (this.isReference) {\n\t\t\t\tthrowBindingError(\"null is not a valid \" + this.name)\n\t\t\t}\n\t\t\treturn 0\n\t\t}\n\t\tif (!handle.$$) {\n\t\t\tthrowBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name)\n\t\t}\n\t\tif (!handle.$$.ptr) {\n\t\t\tthrowBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name)\n\t\t}\n\t\tif (handle.$$.ptrType.isConst) {\n\t\t\tthrowBindingError(\"Cannot convert argument of type \" + handle.$$.ptrType.name + \" to parameter type \" + this.name)\n\t\t}\n\t\tvar handleClass = handle.$$.ptrType.registeredClass;\n\t\tvar ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n\t\treturn ptr\n\t}\n\n\tfunction RegisteredPointer_getPointee(ptr) {\n\t\tif (this.rawGetPointee) {\n\t\t\tptr = this.rawGetPointee(ptr)\n\t\t}\n\t\treturn ptr\n\t}\n\n\tfunction RegisteredPointer_destructor(ptr) {\n\t\tif (this.rawDestructor) {\n\t\t\tthis.rawDestructor(ptr)\n\t\t}\n\t}\n\n\tfunction RegisteredPointer_deleteObject(handle) {\n\t\tif (handle !== null) {\n\t\t\thandle[\"delete\"]()\n\t\t}\n\t}\n\n\tfunction downcastPointer(ptr, ptrClass, desiredClass) {\n\t\tif (ptrClass === desiredClass) {\n\t\t\treturn ptr\n\t\t}\n\t\tif (undefined === desiredClass.baseClass) {\n\t\t\treturn null\n\t\t}\n\t\tvar rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n\t\tif (rv === null) {\n\t\t\treturn null\n\t\t}\n\t\treturn desiredClass.downcast(rv)\n\t}\n\n\tfunction getInheritedInstanceCount() {\n\t\treturn Object.keys(registeredInstances).length\n\t}\n\n\tfunction getLiveInheritedInstances() {\n\t\tvar rv = [];\n\t\tfor (var k in registeredInstances) {\n\t\t\tif (registeredInstances.hasOwnProperty(k)) {\n\t\t\t\trv.push(registeredInstances[k])\n\t\t\t}\n\t\t}\n\t\treturn rv\n\t}\n\n\tfunction setDelayFunction(fn) {\n\t\tdelayFunction = fn;\n\t\tif (deletionQueue.length && delayFunction) {\n\t\t\tdelayFunction(flushPendingDeletes)\n\t\t}\n\t}\n\n\tfunction init_embind() {\n\t\tModule[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n\t\tModule[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n\t\tModule[\"flushPendingDeletes\"] = flushPendingDeletes;\n\t\tModule[\"setDelayFunction\"] = setDelayFunction\n\t}\n\tvar registeredInstances = {};\n\n\tfunction getBasestPointer(class_, ptr) {\n\t\tif (ptr === undefined) {\n\t\t\tthrowBindingError(\"ptr should not be undefined\")\n\t\t}\n\t\twhile (class_.baseClass) {\n\t\t\tptr = class_.upcast(ptr);\n\t\t\tclass_ = class_.baseClass\n\t\t}\n\t\treturn ptr\n\t}\n\n\tfunction getInheritedInstance(class_, ptr) {\n\t\tptr = getBasestPointer(class_, ptr);\n\t\treturn registeredInstances[ptr]\n\t}\n\n\tfunction makeClassHandle(prototype, record) {\n\t\tif (!record.ptrType || !record.ptr) {\n\t\t\tthrowInternalError(\"makeClassHandle requires ptr and ptrType\")\n\t\t}\n\t\tvar hasSmartPtrType = !!record.smartPtrType;\n\t\tvar hasSmartPtr = !!record.smartPtr;\n\t\tif (hasSmartPtrType !== hasSmartPtr) {\n\t\t\tthrowInternalError(\"Both smartPtrType and smartPtr must be specified\")\n\t\t}\n\t\trecord.count = {\n\t\t\tvalue: 1\n\t\t};\n\t\treturn attachFinalizer(Object.create(prototype, {\n\t\t\t$$: {\n\t\t\t\tvalue: record\n\t\t\t}\n\t\t}))\n\t}\n\n\tfunction RegisteredPointer_fromWireType(ptr) {\n\t\tvar rawPointer = this.getPointee(ptr);\n\t\tif (!rawPointer) {\n\t\t\tthis.destructor(ptr);\n\t\t\treturn null\n\t\t}\n\t\tvar registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n\t\tif (undefined !== registeredInstance) {\n\t\t\tif (0 === registeredInstance.$$.count.value) {\n\t\t\t\tregisteredInstance.$$.ptr = rawPointer;\n\t\t\t\tregisteredInstance.$$.smartPtr = ptr;\n\t\t\t\treturn registeredInstance[\"clone\"]()\n\t\t\t} else {\n\t\t\t\tvar rv = registeredInstance[\"clone\"]();\n\t\t\t\tthis.destructor(ptr);\n\t\t\t\treturn rv\n\t\t\t}\n\t\t}\n\n\t\tfunction makeDefaultHandle() {\n\t\t\tif (this.isSmartPointer) {\n\t\t\t\treturn makeClassHandle(this.registeredClass.instancePrototype, {\n\t\t\t\t\tptrType: this.pointeeType,\n\t\t\t\t\tptr: rawPointer,\n\t\t\t\t\tsmartPtrType: this,\n\t\t\t\t\tsmartPtr: ptr\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn makeClassHandle(this.registeredClass.instancePrototype, {\n\t\t\t\t\tptrType: this,\n\t\t\t\t\tptr: ptr\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tvar actualType = this.registeredClass.getActualType(rawPointer);\n\t\tvar registeredPointerRecord = registeredPointers[actualType];\n\t\tif (!registeredPointerRecord) {\n\t\t\treturn makeDefaultHandle.call(this)\n\t\t}\n\t\tvar toType;\n\t\tif (this.isConst) {\n\t\t\ttoType = registeredPointerRecord.constPointerType\n\t\t} else {\n\t\t\ttoType = registeredPointerRecord.pointerType\n\t\t}\n\t\tvar dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n\t\tif (dp === null) {\n\t\t\treturn makeDefaultHandle.call(this)\n\t\t}\n\t\tif (this.isSmartPointer) {\n\t\t\treturn makeClassHandle(toType.registeredClass.instancePrototype, {\n\t\t\t\tptrType: toType,\n\t\t\t\tptr: dp,\n\t\t\t\tsmartPtrType: this,\n\t\t\t\tsmartPtr: ptr\n\t\t\t})\n\t\t} else {\n\t\t\treturn makeClassHandle(toType.registeredClass.instancePrototype, {\n\t\t\t\tptrType: toType,\n\t\t\t\tptr: dp\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction init_RegisteredPointer() {\n\t\tRegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n\t\tRegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n\t\tRegisteredPointer.prototype[\"argPackAdvance\"] = 8;\n\t\tRegisteredPointer.prototype[\"readValueFromPointer\"] = simpleReadValueFromPointer;\n\t\tRegisteredPointer.prototype[\"deleteObject\"] = RegisteredPointer_deleteObject;\n\t\tRegisteredPointer.prototype[\"fromWireType\"] = RegisteredPointer_fromWireType\n\t}\n\n\tfunction RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n\t\tthis.name = name;\n\t\tthis.registeredClass = registeredClass;\n\t\tthis.isReference = isReference;\n\t\tthis.isConst = isConst;\n\t\tthis.isSmartPointer = isSmartPointer;\n\t\tthis.pointeeType = pointeeType;\n\t\tthis.sharingPolicy = sharingPolicy;\n\t\tthis.rawGetPointee = rawGetPointee;\n\t\tthis.rawConstructor = rawConstructor;\n\t\tthis.rawShare = rawShare;\n\t\tthis.rawDestructor = rawDestructor;\n\t\tif (!isSmartPointer && registeredClass.baseClass === undefined) {\n\t\t\tif (isConst) {\n\t\t\t\tthis[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n\t\t\t\tthis.destructorFunction = null\n\t\t\t} else {\n\t\t\t\tthis[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n\t\t\t\tthis.destructorFunction = null\n\t\t\t}\n\t\t} else {\n\t\t\tthis[\"toWireType\"] = genericPointerToWireType\n\t\t}\n\t}\n\n\tfunction replacePublicSymbol(name, value, numArguments) {\n\t\tif (!Module.hasOwnProperty(name)) {\n\t\t\tthrowInternalError(\"Replacing nonexistant public symbol\")\n\t\t}\n\t\tif (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n\t\t\tModule[name].overloadTable[numArguments] = value\n\t\t} else {\n\t\t\tModule[name] = value;\n\t\t\tModule[name].argCount = numArguments\n\t\t}\n\t}\n\n\tfunction embind__requireFunction(signature, rawFunction) {\n\t\tsignature = readLatin1String(signature);\n\n\t\tfunction makeDynCaller(dynCall) {\n\t\t\tvar args = [];\n\t\t\tfor (var i = 1; i < signature.length; ++i) {\n\t\t\t\targs.push(\"a\" + i)\n\t\t\t}\n\t\t\tvar name = \"dynCall_\" + signature + \"_\" + rawFunction;\n\t\t\tvar body = \"return function \" + name + \"(\" + args.join(\", \") + \") {\\n\";\n\t\t\tbody += \"    return dynCall(rawFunction\" + (args.length ? \", \" : \"\") + args.join(\", \") + \");\\n\";\n\t\t\tbody += \"};\\n\";\n\t\t\treturn new Function(\"dynCall\", \"rawFunction\", body)(dynCall, rawFunction)\n\t\t}\n\t\tvar dc = Module[\"dynCall_\" + signature];\n\t\tvar fp = makeDynCaller(dc);\n\t\tif (typeof fp !== \"function\") {\n\t\t\tthrowBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction)\n\t\t}\n\t\treturn fp\n\t}\n\tvar UnboundTypeError = undefined;\n\n\tfunction getTypeName(type) {\n\t\tvar ptr = ___getTypeName(type);\n\t\tvar rv = readLatin1String(ptr);\n\t\t_free(ptr);\n\t\treturn rv\n\t}\n\n\tfunction throwUnboundTypeError(message, types) {\n\t\tvar unboundTypes = [];\n\t\tvar seen = {};\n\n\t\tfunction visit(type) {\n\t\t\tif (seen[type]) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (registeredTypes[type]) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (typeDependencies[type]) {\n\t\t\t\ttypeDependencies[type].forEach(visit);\n\t\t\t\treturn\n\t\t\t}\n\t\t\tunboundTypes.push(type);\n\t\t\tseen[type] = true\n\t\t}\n\t\ttypes.forEach(visit);\n\t\tthrow new UnboundTypeError(message + \": \" + unboundTypes.map(getTypeName).join([\", \"]))\n\t}\n\n\tfunction __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n\t\tname = readLatin1String(name);\n\t\tgetActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n\t\tif (upcast) {\n\t\t\tupcast = embind__requireFunction(upcastSignature, upcast)\n\t\t}\n\t\tif (downcast) {\n\t\t\tdowncast = embind__requireFunction(downcastSignature, downcast)\n\t\t}\n\t\trawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n\t\tvar legalFunctionName = makeLegalFunctionName(name);\n\t\texposePublicSymbol(legalFunctionName, function () {\n\t\t\tthrowUnboundTypeError(\"Cannot construct \" + name + \" due to unbound types\", [baseClassRawType])\n\t\t});\n\t\twhenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function (base) {\n\t\t\tbase = base[0];\n\t\t\tvar baseClass;\n\t\t\tvar basePrototype;\n\t\t\tif (baseClassRawType) {\n\t\t\t\tbaseClass = base.registeredClass;\n\t\t\t\tbasePrototype = baseClass.instancePrototype\n\t\t\t} else {\n\t\t\t\tbasePrototype = ClassHandle.prototype\n\t\t\t}\n\t\t\tvar constructor = createNamedFunction(legalFunctionName, function () {\n\t\t\t\tif (Object.getPrototypeOf(this) !== instancePrototype) {\n\t\t\t\t\tthrow new BindingError(\"Use 'new' to construct \" + name)\n\t\t\t\t}\n\t\t\t\tif (undefined === registeredClass.constructor_body) {\n\t\t\t\t\tthrow new BindingError(name + \" has no accessible constructor\")\n\t\t\t\t}\n\t\t\t\tvar body = registeredClass.constructor_body[arguments.length];\n\t\t\t\tif (undefined === body) {\n\t\t\t\t\tthrow new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\")\n\t\t\t\t}\n\t\t\t\treturn body.apply(this, arguments)\n\t\t\t});\n\t\t\tvar instancePrototype = Object.create(basePrototype, {\n\t\t\t\tconstructor: {\n\t\t\t\t\tvalue: constructor\n\t\t\t\t}\n\t\t\t});\n\t\t\tconstructor.prototype = instancePrototype;\n\t\t\tvar registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n\t\t\tvar referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n\t\t\tvar pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n\t\t\tvar constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n\t\t\tregisteredPointers[rawType] = {\n\t\t\t\tpointerType: pointerConverter,\n\t\t\t\tconstPointerType: constPointerConverter\n\t\t\t};\n\t\t\treplacePublicSymbol(legalFunctionName, constructor);\n\t\t\treturn [referenceConverter, pointerConverter, constPointerConverter]\n\t\t})\n\t}\n\n\tfunction heap32VectorToArray(count, firstElement) {\n\t\tvar array = [];\n\t\tfor (var i = 0; i < count; i++) {\n\t\t\tarray.push(HEAP32[(firstElement >> 2) + i])\n\t\t}\n\t\treturn array\n\t}\n\n\tfunction __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n\t\tassert(argCount > 0);\n\t\tvar rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n\t\tinvoker = embind__requireFunction(invokerSignature, invoker);\n\t\tvar args = [rawConstructor];\n\t\tvar destructors = [];\n\t\twhenDependentTypesAreResolved([], [rawClassType], function (classType) {\n\t\t\tclassType = classType[0];\n\t\t\tvar humanName = \"constructor \" + classType.name;\n\t\t\tif (undefined === classType.registeredClass.constructor_body) {\n\t\t\t\tclassType.registeredClass.constructor_body = []\n\t\t\t}\n\t\t\tif (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n\t\t\t\tthrow new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount - 1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\")\n\t\t\t}\n\t\t\tclassType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {\n\t\t\t\tthrowUnboundTypeError(\"Cannot construct \" + classType.name + \" due to unbound types\", rawArgTypes)\n\t\t\t};\n\t\t\twhenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n\t\t\t\tclassType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {\n\t\t\t\t\tif (arguments.length !== argCount - 1) {\n\t\t\t\t\t\tthrowBindingError(humanName + \" called with \" + arguments.length + \" arguments, expected \" + (argCount - 1))\n\t\t\t\t\t}\n\t\t\t\t\tdestructors.length = 0;\n\t\t\t\t\targs.length = argCount;\n\t\t\t\t\tfor (var i = 1; i < argCount; ++i) {\n\t\t\t\t\t\targs[i] = argTypes[i][\"toWireType\"](destructors, arguments[i - 1])\n\t\t\t\t\t}\n\t\t\t\t\tvar ptr = invoker.apply(null, args);\n\t\t\t\t\trunDestructors(destructors);\n\t\t\t\t\treturn argTypes[0][\"fromWireType\"](ptr)\n\t\t\t\t};\n\t\t\t\treturn []\n\t\t\t});\n\t\t\treturn []\n\t\t})\n\t}\n\n\tfunction new_(constructor, argumentList) {\n\t\tif (!(constructor instanceof Function)) {\n\t\t\tthrow new TypeError(\"new_ called with constructor type \" + typeof constructor + \" which is not a function\")\n\t\t}\n\t\tvar dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function () {});\n\t\tdummy.prototype = constructor.prototype;\n\t\tvar obj = new dummy;\n\t\tvar r = constructor.apply(obj, argumentList);\n\t\treturn r instanceof Object ? r : obj\n\t}\n\n\tfunction craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\n\t\tvar argCount = argTypes.length;\n\t\tif (argCount < 2) {\n\t\t\tthrowBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\")\n\t\t}\n\t\tvar isClassMethodFunc = argTypes[1] !== null && classType !== null;\n\t\tvar needsDestructorStack = false;\n\t\tfor (var i = 1; i < argTypes.length; ++i) {\n\t\t\tif (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n\t\t\t\tneedsDestructorStack = true;\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tvar returns = argTypes[0].name !== \"void\";\n\t\tvar argsList = \"\";\n\t\tvar argsListWired = \"\";\n\t\tfor (var i = 0; i < argCount - 2; ++i) {\n\t\t\targsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n\t\t\targsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\"\n\t\t}\n\t\tvar invokerFnBody = \"return function \" + makeLegalFunctionName(humanName) + \"(\" + argsList + \") {\\n\" + \"if (arguments.length !== \" + (argCount - 2) + \") {\\n\" + \"throwBindingError('function \" + humanName + \" called with ' + arguments.length + ' arguments, expected \" + (argCount - 2) + \" args!');\\n\" + \"}\\n\";\n\t\tif (needsDestructorStack) {\n\t\t\tinvokerFnBody += \"var destructors = [];\\n\"\n\t\t}\n\t\tvar dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n\t\tvar args1 = [\"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\n\t\tvar args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\n\t\tif (isClassMethodFunc) {\n\t\t\tinvokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\"\n\t\t}\n\t\tfor (var i = 0; i < argCount - 2; ++i) {\n\t\t\tinvokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n\t\t\targs1.push(\"argType\" + i);\n\t\t\targs2.push(argTypes[i + 2])\n\t\t}\n\t\tif (isClassMethodFunc) {\n\t\t\targsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired\n\t\t}\n\t\tinvokerFnBody += (returns ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n\t\tif (needsDestructorStack) {\n\t\t\tinvokerFnBody += \"runDestructors(destructors);\\n\"\n\t\t} else {\n\t\t\tfor (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n\t\t\t\tvar paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n\t\t\t\tif (argTypes[i].destructorFunction !== null) {\n\t\t\t\t\tinvokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n\t\t\t\t\targs1.push(paramName + \"_dtor\");\n\t\t\t\t\targs2.push(argTypes[i].destructorFunction)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (returns) {\n\t\t\tinvokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\"\n\t\t} else {}\n\t\tinvokerFnBody += \"}\\n\";\n\t\targs1.push(invokerFnBody);\n\t\tvar invokerFunction = new_(Function, args1).apply(null, args2);\n\t\treturn invokerFunction\n\t}\n\n\tfunction __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {\n\t\tvar rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n\t\tmethodName = readLatin1String(methodName);\n\t\trawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n\t\twhenDependentTypesAreResolved([], [rawClassType], function (classType) {\n\t\t\tclassType = classType[0];\n\t\t\tvar humanName = classType.name + \".\" + methodName;\n\t\t\tif (isPureVirtual) {\n\t\t\t\tclassType.registeredClass.pureVirtualFunctions.push(methodName)\n\t\t\t}\n\n\t\t\tfunction unboundTypesHandler() {\n\t\t\t\tthrowUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes)\n\t\t\t}\n\t\t\tvar proto = classType.registeredClass.instancePrototype;\n\t\t\tvar method = proto[methodName];\n\t\t\tif (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n\t\t\t\tunboundTypesHandler.argCount = argCount - 2;\n\t\t\t\tunboundTypesHandler.className = classType.name;\n\t\t\t\tproto[methodName] = unboundTypesHandler\n\t\t\t} else {\n\t\t\t\tensureOverloadTable(proto, methodName, humanName);\n\t\t\t\tproto[methodName].overloadTable[argCount - 2] = unboundTypesHandler\n\t\t\t}\n\t\t\twhenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n\t\t\t\tvar memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\n\t\t\t\tif (undefined === proto[methodName].overloadTable) {\n\t\t\t\t\tmemberFunction.argCount = argCount - 2;\n\t\t\t\t\tproto[methodName] = memberFunction\n\t\t\t\t} else {\n\t\t\t\t\tproto[methodName].overloadTable[argCount - 2] = memberFunction\n\t\t\t\t}\n\t\t\t\treturn []\n\t\t\t});\n\t\t\treturn []\n\t\t})\n\t}\n\tvar emval_free_list = [];\n\tvar emval_handle_array = [{}, {\n\t\tvalue: undefined\n\t}, {\n\t\tvalue: null\n\t}, {\n\t\tvalue: true\n\t}, {\n\t\tvalue: false\n\t}];\n\n\tfunction __emval_decref(handle) {\n\t\tif (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n\t\t\temval_handle_array[handle] = undefined;\n\t\t\temval_free_list.push(handle)\n\t\t}\n\t}\n\n\tfunction count_emval_handles() {\n\t\tvar count = 0;\n\t\tfor (var i = 5; i < emval_handle_array.length; ++i) {\n\t\t\tif (emval_handle_array[i] !== undefined) {\n\t\t\t\t++count\n\t\t\t}\n\t\t}\n\t\treturn count\n\t}\n\n\tfunction get_first_emval() {\n\t\tfor (var i = 5; i < emval_handle_array.length; ++i) {\n\t\t\tif (emval_handle_array[i] !== undefined) {\n\t\t\t\treturn emval_handle_array[i]\n\t\t\t}\n\t\t}\n\t\treturn null\n\t}\n\n\tfunction init_emval() {\n\t\tModule[\"count_emval_handles\"] = count_emval_handles;\n\t\tModule[\"get_first_emval\"] = get_first_emval\n\t}\n\n\tfunction __emval_register(value) {\n\t\tswitch (value) {\n\t\t\tcase undefined: {\n\t\t\t\treturn 1\n\t\t\t}\n\t\t\tcase null: {\n\t\t\t\treturn 2\n\t\t\t}\n\t\t\tcase true: {\n\t\t\t\treturn 3\n\t\t\t}\n\t\t\tcase false: {\n\t\t\t\treturn 4\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tvar handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;\n\t\t\t\temval_handle_array[handle] = {\n\t\t\t\t\trefcount: 1,\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\t\t\t\treturn handle\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction __embind_register_emval(rawType, name) {\n\t\tname = readLatin1String(name);\n\t\tregisterType(rawType, {\n\t\t\tname: name,\n\t\t\t\"fromWireType\": function (handle) {\n\t\t\t\tvar rv = emval_handle_array[handle].value;\n\t\t\t\t__emval_decref(handle);\n\t\t\t\treturn rv\n\t\t\t},\n\t\t\t\"toWireType\": function (destructors, value) {\n\t\t\t\treturn __emval_register(value)\n\t\t\t},\n\t\t\t\"argPackAdvance\": 8,\n\t\t\t\"readValueFromPointer\": simpleReadValueFromPointer,\n\t\t\tdestructorFunction: null\n\t\t})\n\t}\n\n\tfunction _embind_repr(v) {\n\t\tif (v === null) {\n\t\t\treturn \"null\"\n\t\t}\n\t\tvar t = typeof v;\n\t\tif (t === \"object\" || t === \"array\" || t === \"function\") {\n\t\t\treturn v.toString()\n\t\t} else {\n\t\t\treturn \"\" + v\n\t\t}\n\t}\n\n\tfunction floatReadValueFromPointer(name, shift) {\n\t\tswitch (shift) {\n\t\t\tcase 2:\n\t\t\t\treturn function (pointer) {\n\t\t\t\t\treturn this[\"fromWireType\"](HEAPF32[pointer >> 2])\n\t\t\t\t};\n\t\t\tcase 3:\n\t\t\t\treturn function (pointer) {\n\t\t\t\t\treturn this[\"fromWireType\"](HEAPF64[pointer >> 3])\n\t\t\t\t};\n\t\t\tdefault:\n\t\t\t\tthrow new TypeError(\"Unknown float type: \" + name)\n\t\t}\n\t}\n\n\tfunction __embind_register_float(rawType, name, size) {\n\t\tvar shift = getShiftFromSize(size);\n\t\tname = readLatin1String(name);\n\t\tregisterType(rawType, {\n\t\t\tname: name,\n\t\t\t\"fromWireType\": function (value) {\n\t\t\t\treturn value\n\t\t\t},\n\t\t\t\"toWireType\": function (destructors, value) {\n\t\t\t\tif (typeof value !== \"number\" && typeof value !== \"boolean\") {\n\t\t\t\t\tthrow new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name)\n\t\t\t\t}\n\t\t\t\treturn value\n\t\t\t},\n\t\t\t\"argPackAdvance\": 8,\n\t\t\t\"readValueFromPointer\": floatReadValueFromPointer(name, shift),\n\t\t\tdestructorFunction: null\n\t\t})\n\t}\n\n\tfunction integerReadValueFromPointer(name, shift, signed) {\n\t\tswitch (shift) {\n\t\t\tcase 0:\n\t\t\t\treturn signed ? function readS8FromPointer(pointer) {\n\t\t\t\t\treturn HEAP8[pointer]\n\t\t\t\t} : function readU8FromPointer(pointer) {\n\t\t\t\t\treturn HEAPU8[pointer]\n\t\t\t\t};\n\t\t\tcase 1:\n\t\t\t\treturn signed ? function readS16FromPointer(pointer) {\n\t\t\t\t\treturn HEAP16[pointer >> 1]\n\t\t\t\t} : function readU16FromPointer(pointer) {\n\t\t\t\t\treturn HEAPU16[pointer >> 1]\n\t\t\t\t};\n\t\t\tcase 2:\n\t\t\t\treturn signed ? function readS32FromPointer(pointer) {\n\t\t\t\t\treturn HEAP32[pointer >> 2]\n\t\t\t\t} : function readU32FromPointer(pointer) {\n\t\t\t\t\treturn HEAPU32[pointer >> 2]\n\t\t\t\t};\n\t\t\tdefault:\n\t\t\t\tthrow new TypeError(\"Unknown integer type: \" + name)\n\t\t}\n\t}\n\n\tfunction __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n\t\tname = readLatin1String(name);\n\t\tif (maxRange === -1) {\n\t\t\tmaxRange = 4294967295\n\t\t}\n\t\tvar shift = getShiftFromSize(size);\n\t\tvar fromWireType = function (value) {\n\t\t\treturn value\n\t\t};\n\t\tif (minRange === 0) {\n\t\t\tvar bitshift = 32 - 8 * size;\n\t\t\tfromWireType = function (value) {\n\t\t\t\treturn value << bitshift >>> bitshift\n\t\t\t}\n\t\t}\n\t\tvar isUnsignedType = name.indexOf(\"unsigned\") != -1;\n\t\tregisterType(primitiveType, {\n\t\t\tname: name,\n\t\t\t\"fromWireType\": fromWireType,\n\t\t\t\"toWireType\": function (destructors, value) {\n\t\t\t\tif (typeof value !== \"number\" && typeof value !== \"boolean\") {\n\t\t\t\t\tthrow new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name)\n\t\t\t\t}\n\t\t\t\tif (value < minRange || value > maxRange) {\n\t\t\t\t\tthrow new TypeError('Passing a number \"' + _embind_repr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + \", \" + maxRange + \"]!\")\n\t\t\t\t}\n\t\t\t\treturn isUnsignedType ? value >>> 0 : value | 0\n\t\t\t},\n\t\t\t\"argPackAdvance\": 8,\n\t\t\t\"readValueFromPointer\": integerReadValueFromPointer(name, shift, minRange !== 0),\n\t\t\tdestructorFunction: null\n\t\t})\n\t}\n\n\tfunction __embind_register_memory_view(rawType, dataTypeIndex, name) {\n\t\tvar typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n\t\tvar TA = typeMapping[dataTypeIndex];\n\n\t\tfunction decodeMemoryView(handle) {\n\t\t\thandle = handle >> 2;\n\t\t\tvar heap = HEAPU32;\n\t\t\tvar size = heap[handle];\n\t\t\tvar data = heap[handle + 1];\n\t\t\treturn new TA(buffer, data, size)\n\t\t}\n\t\tname = readLatin1String(name);\n\t\tregisterType(rawType, {\n\t\t\tname: name,\n\t\t\t\"fromWireType\": decodeMemoryView,\n\t\t\t\"argPackAdvance\": 8,\n\t\t\t\"readValueFromPointer\": decodeMemoryView\n\t\t}, {\n\t\t\tignoreDuplicateRegistrations: true\n\t\t})\n\t}\n\n\tfunction __embind_register_std_string(rawType, name) {\n\t\tname = readLatin1String(name);\n\t\tvar stdStringIsUTF8 = name === \"std::string\";\n\t\tregisterType(rawType, {\n\t\t\tname: name,\n\t\t\t\"fromWireType\": function (value) {\n\t\t\t\tvar length = HEAPU32[value >> 2];\n\t\t\t\tvar str;\n\t\t\t\tif (stdStringIsUTF8) {\n\t\t\t\t\tvar decodeStartPtr = value + 4;\n\t\t\t\t\tfor (var i = 0; i <= length; ++i) {\n\t\t\t\t\t\tvar currentBytePtr = value + 4 + i;\n\t\t\t\t\t\tif (HEAPU8[currentBytePtr] == 0 || i == length) {\n\t\t\t\t\t\t\tvar maxRead = currentBytePtr - decodeStartPtr;\n\t\t\t\t\t\t\tvar stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n\t\t\t\t\t\t\tif (str === undefined) {\n\t\t\t\t\t\t\t\tstr = stringSegment\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstr += String.fromCharCode(0);\n\t\t\t\t\t\t\t\tstr += stringSegment\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdecodeStartPtr = currentBytePtr + 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar a = new Array(length);\n\t\t\t\t\tfor (var i = 0; i < length; ++i) {\n\t\t\t\t\t\ta[i] = String.fromCharCode(HEAPU8[value + 4 + i])\n\t\t\t\t\t}\n\t\t\t\t\tstr = a.join(\"\")\n\t\t\t\t}\n\t\t\t\t_free(value);\n\t\t\t\treturn str\n\t\t\t},\n\t\t\t\"toWireType\": function (destructors, value) {\n\t\t\t\tif (value instanceof ArrayBuffer) {\n\t\t\t\t\tvalue = new Uint8Array(value)\n\t\t\t\t}\n\t\t\t\tvar getLength;\n\t\t\t\tvar valueIsOfTypeString = typeof value === \"string\";\n\t\t\t\tif (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n\t\t\t\t\tthrowBindingError(\"Cannot pass non-string to std::string\")\n\t\t\t\t}\n\t\t\t\tif (stdStringIsUTF8 && valueIsOfTypeString) {\n\t\t\t\t\tgetLength = function () {\n\t\t\t\t\t\treturn lengthBytesUTF8(value)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgetLength = function () {\n\t\t\t\t\t\treturn value.length\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar length = getLength();\n\t\t\t\tvar ptr = _malloc(4 + length + 1);\n\t\t\t\tHEAPU32[ptr >> 2] = length;\n\t\t\t\tif (stdStringIsUTF8 && valueIsOfTypeString) {\n\t\t\t\t\tstringToUTF8(value, ptr + 4, length + 1)\n\t\t\t\t} else {\n\t\t\t\t\tif (valueIsOfTypeString) {\n\t\t\t\t\t\tfor (var i = 0; i < length; ++i) {\n\t\t\t\t\t\t\tvar charCode = value.charCodeAt(i);\n\t\t\t\t\t\t\tif (charCode > 255) {\n\t\t\t\t\t\t\t\t_free(ptr);\n\t\t\t\t\t\t\t\tthrowBindingError(\"String has UTF-16 code units that do not fit in 8 bits\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tHEAPU8[ptr + 4 + i] = charCode\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (var i = 0; i < length; ++i) {\n\t\t\t\t\t\t\tHEAPU8[ptr + 4 + i] = value[i]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (destructors !== null) {\n\t\t\t\t\tdestructors.push(_free, ptr)\n\t\t\t\t}\n\t\t\t\treturn ptr\n\t\t\t},\n\t\t\t\"argPackAdvance\": 8,\n\t\t\t\"readValueFromPointer\": simpleReadValueFromPointer,\n\t\t\tdestructorFunction: function (ptr) {\n\t\t\t\t_free(ptr)\n\t\t\t}\n\t\t})\n\t}\n\n\tfunction __embind_register_std_wstring(rawType, charSize, name) {\n\t\tname = readLatin1String(name);\n\t\tvar decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n\t\tif (charSize === 2) {\n\t\t\tdecodeString = UTF16ToString;\n\t\t\tencodeString = stringToUTF16;\n\t\t\tlengthBytesUTF = lengthBytesUTF16;\n\t\t\tgetHeap = function () {\n\t\t\t\treturn HEAPU16\n\t\t\t};\n\t\t\tshift = 1\n\t\t} else if (charSize === 4) {\n\t\t\tdecodeString = UTF32ToString;\n\t\t\tencodeString = stringToUTF32;\n\t\t\tlengthBytesUTF = lengthBytesUTF32;\n\t\t\tgetHeap = function () {\n\t\t\t\treturn HEAPU32\n\t\t\t};\n\t\t\tshift = 2\n\t\t}\n\t\tregisterType(rawType, {\n\t\t\tname: name,\n\t\t\t\"fromWireType\": function (value) {\n\t\t\t\tvar length = HEAPU32[value >> 2];\n\t\t\t\tvar HEAP = getHeap();\n\t\t\t\tvar str;\n\t\t\t\tvar decodeStartPtr = value + 4;\n\t\t\t\tfor (var i = 0; i <= length; ++i) {\n\t\t\t\t\tvar currentBytePtr = value + 4 + i * charSize;\n\t\t\t\t\tif (HEAP[currentBytePtr >> shift] == 0 || i == length) {\n\t\t\t\t\t\tvar maxReadBytes = currentBytePtr - decodeStartPtr;\n\t\t\t\t\t\tvar stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n\t\t\t\t\t\tif (str === undefined) {\n\t\t\t\t\t\t\tstr = stringSegment\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstr += String.fromCharCode(0);\n\t\t\t\t\t\t\tstr += stringSegment\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdecodeStartPtr = currentBytePtr + charSize\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_free(value);\n\t\t\t\treturn str\n\t\t\t},\n\t\t\t\"toWireType\": function (destructors, value) {\n\t\t\t\tif (!(typeof value === \"string\")) {\n\t\t\t\t\tthrowBindingError(\"Cannot pass non-string to C++ string type \" + name)\n\t\t\t\t}\n\t\t\t\tvar length = lengthBytesUTF(value);\n\t\t\t\tvar ptr = _malloc(4 + length + charSize);\n\t\t\t\tHEAPU32[ptr >> 2] = length >> shift;\n\t\t\t\tencodeString(value, ptr + 4, length + charSize);\n\t\t\t\tif (destructors !== null) {\n\t\t\t\t\tdestructors.push(_free, ptr)\n\t\t\t\t}\n\t\t\t\treturn ptr\n\t\t\t},\n\t\t\t\"argPackAdvance\": 8,\n\t\t\t\"readValueFromPointer\": simpleReadValueFromPointer,\n\t\t\tdestructorFunction: function (ptr) {\n\t\t\t\t_free(ptr)\n\t\t\t}\n\t\t})\n\t}\n\n\tfunction __embind_register_value_object(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {\n\t\tstructRegistrations[rawType] = {\n\t\t\tname: readLatin1String(name),\n\t\t\trawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n\t\t\trawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n\t\t\tfields: []\n\t\t}\n\t}\n\n\tfunction __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n\t\tstructRegistrations[structType].fields.push({\n\t\t\tfieldName: readLatin1String(fieldName),\n\t\t\tgetterReturnType: getterReturnType,\n\t\t\tgetter: embind__requireFunction(getterSignature, getter),\n\t\t\tgetterContext: getterContext,\n\t\t\tsetterArgumentType: setterArgumentType,\n\t\t\tsetter: embind__requireFunction(setterSignature, setter),\n\t\t\tsetterContext: setterContext\n\t\t})\n\t}\n\n\tfunction __embind_register_void(rawType, name) {\n\t\tname = readLatin1String(name);\n\t\tregisterType(rawType, {\n\t\t\tisVoid: true,\n\t\t\tname: name,\n\t\t\t\"argPackAdvance\": 0,\n\t\t\t\"fromWireType\": function () {\n\t\t\t\treturn undefined\n\t\t\t},\n\t\t\t\"toWireType\": function (destructors, o) {\n\t\t\t\treturn undefined\n\t\t\t}\n\t\t})\n\t}\n\n\tfunction __emval_incref(handle) {\n\t\tif (handle > 4) {\n\t\t\temval_handle_array[handle].refcount += 1\n\t\t}\n\t}\n\n\tfunction requireRegisteredType(rawType, humanName) {\n\t\tvar impl = registeredTypes[rawType];\n\t\tif (undefined === impl) {\n\t\t\tthrowBindingError(humanName + \" has unknown type \" + getTypeName(rawType))\n\t\t}\n\t\treturn impl\n\t}\n\n\tfunction __emval_take_value(type, argv) {\n\t\ttype = requireRegisteredType(type, \"_emval_take_value\");\n\t\tvar v = type[\"readValueFromPointer\"](argv);\n\t\treturn __emval_register(v)\n\t}\n\n\tfunction _abort() {\n\t\tabort()\n\t}\n\n\tfunction _emscripten_get_sbrk_ptr() {\n\t\treturn 45648\n\t}\n\n\tfunction _emscripten_memcpy_big(dest, src, num) {\n\t\tHEAPU8.copyWithin(dest, src, src + num)\n\t}\n\n\tfunction _emscripten_get_heap_size() {\n\t\treturn HEAPU8.length\n\t}\n\n\tfunction emscripten_realloc_buffer(size) {\n\t\ttry {\n\t\t\twasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\n\t\t\tupdateGlobalBufferAndViews(wasmMemory.buffer);\n\t\t\treturn 1\n\t\t} catch (e) {}\n\t}\n\n\tfunction _emscripten_resize_heap(requestedSize) {\n\t\trequestedSize = requestedSize >>> 0;\n\t\tvar oldSize = _emscripten_get_heap_size();\n\t\tvar PAGE_MULTIPLE = 65536;\n\t\tvar maxHeapSize = 2147483648;\n\t\tif (requestedSize > maxHeapSize) {\n\t\t\treturn false\n\t\t}\n\t\tvar minHeapSize = 16777216;\n\t\tfor (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n\t\t\tvar overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n\t\t\toverGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n\t\t\tvar newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE));\n\t\t\tvar replacement = emscripten_realloc_buffer(newSize);\n\t\t\tif (replacement) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tInternalError = Module[\"InternalError\"] = extendError(Error, \"InternalError\");\n\tembind_init_charCodes();\n\tBindingError = Module[\"BindingError\"] = extendError(Error, \"BindingError\");\n\tinit_ClassHandle();\n\tinit_RegisteredPointer();\n\tinit_embind();\n\tUnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n\tinit_emval();\n\tvar ASSERTIONS = false;\n\tvar asmLibraryArg = {\n\t\t\"__cxa_allocate_exception\": ___cxa_allocate_exception,\n\t\t\"__cxa_atexit\": ___cxa_atexit,\n\t\t\"__cxa_throw\": ___cxa_throw,\n\t\t\"_embind_finalize_value_object\": __embind_finalize_value_object,\n\t\t\"_embind_register_bool\": __embind_register_bool,\n\t\t\"_embind_register_class\": __embind_register_class,\n\t\t\"_embind_register_class_constructor\": __embind_register_class_constructor,\n\t\t\"_embind_register_class_function\": __embind_register_class_function,\n\t\t\"_embind_register_emval\": __embind_register_emval,\n\t\t\"_embind_register_float\": __embind_register_float,\n\t\t\"_embind_register_integer\": __embind_register_integer,\n\t\t\"_embind_register_memory_view\": __embind_register_memory_view,\n\t\t\"_embind_register_std_string\": __embind_register_std_string,\n\t\t\"_embind_register_std_wstring\": __embind_register_std_wstring,\n\t\t\"_embind_register_value_object\": __embind_register_value_object,\n\t\t\"_embind_register_value_object_field\": __embind_register_value_object_field,\n\t\t\"_embind_register_void\": __embind_register_void,\n\t\t\"_emval_decref\": __emval_decref,\n\t\t\"_emval_incref\": __emval_incref,\n\t\t\"_emval_take_value\": __emval_take_value,\n\t\t\"abort\": _abort,\n\t\t\"emscripten_get_sbrk_ptr\": _emscripten_get_sbrk_ptr,\n\t\t\"emscripten_memcpy_big\": _emscripten_memcpy_big,\n\t\t\"emscripten_resize_heap\": _emscripten_resize_heap,\n\t\t\"memory\": wasmMemory,\n\t\t\"table\": wasmTable\n\t};\n\tvar asm = createWasm();\n\tvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function () {\n\t\treturn (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = Module[\"asm\"][\"__wasm_call_ctors\"]).apply(null, arguments)\n\t};\n\tvar ___getTypeName = Module[\"___getTypeName\"] = function () {\n\t\treturn (___getTypeName = Module[\"___getTypeName\"] = Module[\"asm\"][\"__getTypeName\"]).apply(null, arguments)\n\t};\n\tvar ___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = function () {\n\t\treturn (___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = Module[\"asm\"][\"__embind_register_native_and_builtin_types\"]).apply(null, arguments)\n\t};\n\tvar ___errno_location = Module[\"___errno_location\"] = function () {\n\t\treturn (___errno_location = Module[\"___errno_location\"] = Module[\"asm\"][\"__errno_location\"]).apply(null, arguments)\n\t};\n\tvar _malloc = Module[\"_malloc\"] = function () {\n\t\treturn (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"malloc\"]).apply(null, arguments)\n\t};\n\tvar _setThrew = Module[\"_setThrew\"] = function () {\n\t\treturn (_setThrew = Module[\"_setThrew\"] = Module[\"asm\"][\"setThrew\"]).apply(null, arguments)\n\t};\n\tvar stackSave = Module[\"stackSave\"] = function () {\n\t\treturn (stackSave = Module[\"stackSave\"] = Module[\"asm\"][\"stackSave\"]).apply(null, arguments)\n\t};\n\tvar stackRestore = Module[\"stackRestore\"] = function () {\n\t\treturn (stackRestore = Module[\"stackRestore\"] = Module[\"asm\"][\"stackRestore\"]).apply(null, arguments)\n\t};\n\tvar stackAlloc = Module[\"stackAlloc\"] = function () {\n\t\treturn (stackAlloc = Module[\"stackAlloc\"] = Module[\"asm\"][\"stackAlloc\"]).apply(null, arguments)\n\t};\n\tvar _free = Module[\"_free\"] = function () {\n\t\treturn (_free = Module[\"_free\"] = Module[\"asm\"][\"free\"]).apply(null, arguments)\n\t};\n\tvar __growWasmMemory = Module[\"__growWasmMemory\"] = function () {\n\t\treturn (__growWasmMemory = Module[\"__growWasmMemory\"] = Module[\"asm\"][\"__growWasmMemory\"]).apply(null, arguments)\n\t};\n\tvar dynCall_i = Module[\"dynCall_i\"] = function () {\n\t\treturn (dynCall_i = Module[\"dynCall_i\"] = Module[\"asm\"][\"dynCall_i\"]).apply(null, arguments)\n\t};\n\tvar dynCall_vi = Module[\"dynCall_vi\"] = function () {\n\t\treturn (dynCall_vi = Module[\"dynCall_vi\"] = Module[\"asm\"][\"dynCall_vi\"]).apply(null, arguments)\n\t};\n\tvar dynCall_iii = Module[\"dynCall_iii\"] = function () {\n\t\treturn (dynCall_iii = Module[\"dynCall_iii\"] = Module[\"asm\"][\"dynCall_iii\"]).apply(null, arguments)\n\t};\n\tvar dynCall_viii = Module[\"dynCall_viii\"] = function () {\n\t\treturn (dynCall_viii = Module[\"dynCall_viii\"] = Module[\"asm\"][\"dynCall_viii\"]).apply(null, arguments)\n\t};\n\tvar dynCall_ii = Module[\"dynCall_ii\"] = function () {\n\t\treturn (dynCall_ii = Module[\"dynCall_ii\"] = Module[\"asm\"][\"dynCall_ii\"]).apply(null, arguments)\n\t};\n\tvar dynCall_iiii = Module[\"dynCall_iiii\"] = function () {\n\t\treturn (dynCall_iiii = Module[\"dynCall_iiii\"] = Module[\"asm\"][\"dynCall_iiii\"]).apply(null, arguments)\n\t};\n\tvar dynCall_vii = Module[\"dynCall_vii\"] = function () {\n\t\treturn (dynCall_vii = Module[\"dynCall_vii\"] = Module[\"asm\"][\"dynCall_vii\"]).apply(null, arguments)\n\t};\n\tvar dynCall_viiii = Module[\"dynCall_viiii\"] = function () {\n\t\treturn (dynCall_viiii = Module[\"dynCall_viiii\"] = Module[\"asm\"][\"dynCall_viiii\"]).apply(null, arguments)\n\t};\n\tvar dynCall_v = Module[\"dynCall_v\"] = function () {\n\t\treturn (dynCall_v = Module[\"dynCall_v\"] = Module[\"asm\"][\"dynCall_v\"]).apply(null, arguments)\n\t};\n\tvar dynCall_viiiiii = Module[\"dynCall_viiiiii\"] = function () {\n\t\treturn (dynCall_viiiiii = Module[\"dynCall_viiiiii\"] = Module[\"asm\"][\"dynCall_viiiiii\"]).apply(null, arguments)\n\t};\n\tvar dynCall_viiiii = Module[\"dynCall_viiiii\"] = function () {\n\t\treturn (dynCall_viiiii = Module[\"dynCall_viiiii\"] = Module[\"asm\"][\"dynCall_viiiii\"]).apply(null, arguments)\n\t};\n\tModule[\"ccall\"] = ccall;\n\tvar calledRun;\n\n\tfunction ExitStatus(status) {\n\t\tthis.name = \"ExitStatus\";\n\t\tthis.message = \"Program terminated with exit(\" + status + \")\";\n\t\tthis.status = status\n\t}\n\tdependenciesFulfilled = function runCaller() {\n\t\tif (!calledRun) run();\n\t\tif (!calledRun) dependenciesFulfilled = runCaller\n\t};\n\n\tfunction run(args) {\n\t\targs = args || arguments_;\n\t\tif (runDependencies > 0) {\n\t\t\treturn\n\t\t}\n\t\tpreRun();\n\t\tif (runDependencies > 0) return;\n\n\t\tfunction doRun() {\n\t\t\tif (calledRun) return;\n\t\t\tcalledRun = true;\n\t\t\tModule[\"calledRun\"] = true;\n\t\t\tif (ABORT) return;\n\t\t\tinitRuntime();\n\t\t\tpreMain();\n\t\t\tif (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"](Module);\n\t\t\tpostRun()\n\t\t}\n\t\tif (Module[\"setStatus\"]) {\n\t\t\tModule[\"setStatus\"](\"Running...\");\n\t\t\tsetTimeout(function () {\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tModule[\"setStatus\"](\"\")\n\t\t\t\t}, 1);\n\t\t\t\tdoRun()\n\t\t\t}, 1)\n\t\t} else {\n\t\t\tdoRun()\n\t\t}\n\t}\n\tModule[\"run\"] = run;\n\tif (Module[\"preInit\"]) {\n\t\tif (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n\t\twhile (Module[\"preInit\"].length > 0) {\n\t\t\tModule[\"preInit\"].pop()()\n\t\t}\n\t}\n\tnoExitRuntime = true;\n\t// pseudo promise\n\tModule.then = (callback) =>  {\n\t\tModule[\"onRuntimeInitialized\"] = callback;\n\t}\n\trun();\n\treturn Module;\n});\n\nexport default CharLS;\n","\"use strict\";\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar global = getGlobal();\n\nmodule.exports = exports = global.fetch;\n\n// Needed for TypeScript and Webpack.\nif (global.fetch) {\n\texports.default = global.fetch.bind(global);\n}\n\nexports.Headers = global.Headers;\nexports.Request = global.Request;\nexports.Response = global.Response;"],"names":["CharLS","opts","key","Module","moduleOverrides","hasOwnProperty","ENVIRONMENT_IS_WEB","ENVIRONMENT_IS_WORKER","ENVIRONMENT_IS_NODE","ENVIRONMENT_IS_SHELL","window","importScripts","process","versions","node","read_","readBinary","nodeFS","nodePath","scriptDirectory","globalThis","fetch","require","__dirname","filename","binary","ret","buffer","Uint8Array","assert","length","replace","slice","module","ex","ExitStatus","abort","read","f","data","readbuffer","scriptArgs","print","console","log","warn","error","printErr","self","location","href","document","currentScript","src","indexOf","substr","lastIndexOf","url","xhr","XMLHttpRequest","open","send","responseText","responseType","response","wasmBinary","wasmMemory","out","bind","err","WebAssembly","wasmTable","Table","ABORT","condition","text","UTF8Decoder","TextDecoder","undefined","UTF8ToString","ptr","maxBytesToRead","heap","idx","endIdx","endPtr","subarray","decode","str","u0","u1","u2","String","fromCharCode","ch","UTF8ArrayToString","HEAPU8","stringToUTF8","outPtr","maxBytesToWrite","outIdx","startIdx","i","u","charCodeAt","stringToUTF8Array","UTF16Decoder","UTF16ToString","maxIdx","HEAPU16","codeUnit","HEAP16","stringToUTF16","startPtr","numCharsToWrite","lengthBytesUTF16","UTF32ToString","utf32","HEAP32","stringToUTF32","lengthBytesUTF32","len","HEAP8","HEAPU32","HEAPF32","HEAPF64","updateGlobalBufferAndViews","buf","Int8Array","Int16Array","Int32Array","Uint16Array","Uint32Array","Float32Array","Float64Array","STACK_BASE","INITIAL_INITIAL_MEMORY","callRuntimeCallbacks","callbacks","callback","shift","func","arg","Memory","byteLength","DYNAMICTOP_PTR","__ATPRERUN__","__ATINIT__","__ATMAIN__","__ATPOSTRUN__","runDependencies","dependenciesFulfilled","what","RuntimeError","hasPrefix","prefix","prototype","startsWith","isDataURI","isFileURI","path","wasmBinaryFile","getBinary","push","___wasm_call_ctors","___exception_infos","structRegistrations","runDestructors","destructors","pop","del","simpleReadValueFromPointer","pointer","this","awaitingDependencies","registeredTypes","typeDependencies","makeLegalFunctionName","name","createNamedFunction","body","Function","extendError","baseErrorType","errorName","errorClass","message","stack","Error","toString","Object","create","constructor","InternalError","throwInternalError","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","registerType","forEach","type","Array","unregisteredTypes","registered","dt","getShiftFromSize","size","TypeError","embind_charCodes","readLatin1String","c","BindingError","throwBindingError","rawType","registeredInstance","options","ignoreDuplicateRegistrations","cb","ClassHandle_isAliasOf","other","ClassHandle","leftClass","$$","ptrType","registeredClass","left","rightClass","right","baseClass","upcast","throwInstanceAlreadyDeleted","obj","finalizationGroup","detachFinalizer","handle","releaseClassHandle","count","value","smartPtr","smartPtrType","rawDestructor","runDestructor","attachFinalizer","FinalizationGroup","iter","result","next","done","register","unregister","ClassHandle_clone","preservePointerOnDelete","o","clone","getPrototypeOf","deleteScheduled","ClassHandle_delete","ClassHandle_isDeleted","delayFunction","deletionQueue","flushPendingDeletes","ClassHandle_deleteLater","registeredPointers","ensureOverloadTable","proto","methodName","humanName","overloadTable","prevFunc","arguments","apply","argCount","RegisteredClass","instancePrototype","getActualType","downcast","pureVirtualFunctions","upcastPointer","ptrClass","desiredClass","constNoSmartPtrRawPointerToWireType","isReference","_embind_repr","handleClass","genericPointerToWireType","isSmartPointer","rawConstructor","isConst","sharingPolicy","clonedHandle","rawShare","__emval_register","nonConstNoSmartPtrRawPointerToWireType","RegisteredPointer_getPointee","rawGetPointee","RegisteredPointer_destructor","RegisteredPointer_deleteObject","downcastPointer","rv","getInheritedInstanceCount","keys","registeredInstances","getLiveInheritedInstances","k","setDelayFunction","fn","getInheritedInstance","class_","getBasestPointer","makeClassHandle","record","RegisteredPointer_fromWireType","rawPointer","getPointee","destructor","makeDefaultHandle","pointeeType","toType","actualType","registeredPointerRecord","call","constPointerType","pointerType","dp","RegisteredPointer","destructorFunction","embind__requireFunction","signature","rawFunction","fp","dynCall","args","join","makeDynCaller","UnboundTypeError","getTypeName","___getTypeName","_free","throwUnboundTypeError","types","unboundTypes","seen","visit","map","heap32VectorToArray","firstElement","array","craftInvokerFunction","argTypes","classType","cppInvokerFunc","cppTargetFunc","isClassMethodFunc","needsDestructorStack","returns","argsList","argsListWired","invokerFnBody","dtorStack","args1","args2","paramName","argumentList","dummy","r","new_","emval_free_list","emval_handle_array","__emval_decref","refcount","count_emval_handles","get_first_emval","v","t","floatReadValueFromPointer","integerReadValueFromPointer","signed","emscripten_realloc_buffer","grow","e","codes","embind_init_charCodes","asmLibraryArg","_malloc","a0","a1","adjusted","caught","rethrown","structType","reg","fieldRecords","fields","field","getterReturnType","concat","setterArgumentType","fieldTypes","fieldName","getter","getterContext","setter","setterContext","write","trueValue","falseValue","wt","rawPointerType","rawConstPointerType","baseClassRawType","getActualTypeSignature","upcastSignature","downcastSignature","destructorSignature","legalFunctionName","numArguments","exposePublicSymbol","base","basePrototype","constructor_body","referenceConverter","pointerConverter","constPointerConverter","replacePublicSymbol","rawClassType","rawArgTypesAddr","invokerSignature","invoker","rawArgTypes","rawInvoker","context","isPureVirtual","unboundTypesHandler","method","className","memberFunction","primitiveType","minRange","maxRange","fromWireType","bitshift","isUnsignedType","dataTypeIndex","TA","decodeMemoryView","stdStringIsUTF8","decodeStartPtr","currentBytePtr","stringSegment","a","getLength","ArrayBuffer","valueIsOfTypeString","Uint8ClampedArray","lengthBytesUTF8","charCode","charSize","decodeString","encodeString","getHeap","lengthBytesUTF","HEAP","constructorSignature","getterSignature","setterSignature","isVoid","argv","impl","requireRegisteredType","dest","num","copyWithin","requestedSize","oldSize","maxHeapSize","x","multiple","cutDown","overGrownHeapSize","Math","min","max","info","receiveInstance","instance","exports","id","removeRunDependency","receiveInstantiatedSource","output","instantiateArrayBuffer","receiver","Promise","resolve","reject","credentials","then","catch","instantiate","reason","instantiateStreaming","instantiateAsync","createWasm","calledRun","stackSave","stackRestore","stackAlloc","status","run","doRun","unshift","postRun","preRun","setTimeout","ident","returnType","toC","arr","set","writeArrayToMemory","getCFunc","cArgs","converter","Boolean","convertReturnValue","runCaller","global","getGlobal","Headers","Request","Response"],"sourceRoot":""}